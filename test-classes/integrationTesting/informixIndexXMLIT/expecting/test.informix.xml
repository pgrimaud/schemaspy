<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<database name="test" schema="informix" type="Informix Dynamic Server - 12.10.FC9W1DE">
   <tables>
      <table catalog="test" name="sysdomains" numRows="0" remarks="" schema="informix" type="VIEW">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="owner" nullable="true" remarks="" size="32" type="char" typeCode="1"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name" nullable="true" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="type" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
      </table>
      <table catalog="test" name="sysindexes" numRows="0" remarks="" schema="informix" type="VIEW">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="idxname" nullable="true" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="owner" nullable="true" remarks="" size="32" type="char" typeCode="1"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="tabid" nullable="true" remarks="" size="10" type="integer" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="idxtype" nullable="true" remarks="" size="1" type="char" typeCode="1"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="clustered" nullable="true" remarks="" size="1" type="char" typeCode="1"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="part1" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="part2" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="part3" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="part4" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="part5" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="part6" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="part7" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="part8" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="part9" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="part10" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="part11" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="part12" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="17" name="part13" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="18" name="part14" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="19" name="part15" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="20" name="part16" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="21" name="levels" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="22" name="leaves" nullable="true" remarks="" size="17" type="float" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="23" name="nunique" nullable="true" remarks="" size="17" type="float" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="24" name="clust" nullable="true" remarks="" size="17" type="float" typeCode="8"/>
      </table>
      <table catalog="test" name="test" numRows="0" remarks="" schema="informix" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="integer" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="firstname" nullable="true" remarks="" size="32" type="char" typeCode="1"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="lastname" nullable="true" remarks="" size="32" type="char" typeCode="1"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="age" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="weight" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="height" nullable="true" remarks="" size="5" type="smallint" typeCode="5"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="100_1" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="test_index" unique="false">
            <column ascending="true" name="firstname"/>
            <column ascending="true" name="lastname"/>
            <column ascending="true" name="age"/>
         </index>
      </table>
   </tables>
   <routines>
      <routine dataAccess="N/A" deterministic="true" name=" systdistold(integer,integer)" returnType="integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="spl"><![CDATA[create dba procedure informix.systdist (table_id int, column_no int)
   returning int, date, char(1),
             smallfloat, smallfloat, stat, char(1);

   define v_tabauth      char(8);
   define v_colauth      char(3);
   define is_allowed     int;
   define search_columns int;
   define v_colno        smallint;
   define v_seqno        int;
   define v_constructed  date;
   define v_mode         char(1);
   define v_resolution   smallfloat;
   define v_confidence   smallfloat;
   define v_encdat       stat;
   define v_owner        char(8);
   define user           procedure;
   define v_stattype	 char(1);

-- First verify that the current user has select privileges on this column

   let is_allowed = 0;
   let search_columns = 0;

-- Check sysusers to see if the usertype is 'D', ie., the
-- current user has dba privileges and may see any columns.
   select usertype
      into v_mode
      from informix.sysusers
      where username = user;
   if v_mode = 'D' then
      let is_allowed = 1;
   else
      -- See if the user owns the table, and therefore can see the columns.
      select owner
         into v_owner
	 from informix.systables
	 where tabid = table_id;
      if v_owner = user then
         let is_allowed = 1;
      end if
   end if

   if is_allowed = 0 then
      foreach
         select tabauth
            into v_tabauth
            from informix.systabauth
            where tabid = table_id and
                  (grantee = user or
                   grantee = 'public')
         if substr(v_tabauth, 1, 1) = 's' or substr(v_tabauth, 1, 1) = 'S' then
            let is_allowed = 1;
            exit foreach;
         elif substr(v_tabauth, 3, 1) = '*' then
            let search_columns = 1;
         end if
      end foreach
   end if

-- Search syscolauth only if user does not have select
-- privileges on all columns.  If the user has no select
-- privileges on any column, then we need search no further.

   if is_allowed = 0 and search_columns = 1 then
      foreach
         select colauth
            into v_colauth
            from informix.syscolauth
            where tabid = table_id and
                  colno = column_no and
                  (grantee = user or
                   grantee = 'public')
         if substr(v_colauth, 1, 1) = 's' or substr(v_colauth, 1, 1) = 'S' then
            let is_allowed = 1;
            exit foreach;
         end if
      end foreach
   end if

-- Return with no rows found if not allowed to select from
-- the column designated by (tabid,colno).

   if is_allowed = 0 then
      raise exception -272;
   end if

-- Now find the distribution rows

   foreach
      select  seqno, constructed, mode,
              resolution, confidence, encdat, type
         into v_seqno, v_constructed, v_mode,
              v_resolution, v_confidence, v_encdat, v_stattype
         from informix.sysdistrib
         where tabid = table_id and
               colno = column_no
         order by seqno
      return v_seqno, v_constructed, v_mode,
             v_resolution, v_confidence, v_encdat, v_stattype
         with resume;
   end foreach

-- Engine will return 100 to user

end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="addtoset2_combine(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.addtoset2_combine(informix.lvarchar, informix.lvarchar)
returns informix.lvarchar with (handlesnulls, not variant)
external name '(bson_addtoset2_combine)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="addtoset2_final(lvarchar)" returnType="lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.addtoset2_final(informix.lvarchar)
returns informix.bson with (handlesnulls, not variant)
external name '(bson_addtoset2_final)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="addtoset2_init(bson)" returnType="bson" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.addtoset2_init(informix.bson)
returns informix.lvarchar with (handlesnulls, not variant)
external name '(bson_addtoset2_init)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="addtoset2_iter(lvarchar,bson)" returnType="lvarchar,bson" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.addtoset2_iter(informix.lvarchar, informix.bson)
returns informix.lvarchar with (handlesnulls, not variant)
external name '(bson_addtoset2_iter)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="addtoset_combine(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.addtoset_combine(informix.lvarchar, informix.lvarchar)
returns informix.lvarchar with (handlesnulls, not variant)
external name '(bson_addtoset_combine)' language c ;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="addtoset_final(lvarchar)" returnType="lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.addtoset_final(informix.lvarchar)
returns informix.bson with (handlesnulls, not variant)
external name '(bson_addtoset_final)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="addtoset_init(bson)" returnType="bson" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.addtoset_init(informix.bson)
returns informix.lvarchar with (handlesnulls, not variant)
external name '(bson_addtoset_init)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="addtoset_iter(lvarchar,bson)" returnType="lvarchar,bson" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.addtoset_iter(informix.lvarchar, informix.bson)
returns informix.lvarchar with (handlesnulls, not variant)
external name '(bson_addtoset_iter)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="alter_java_path(varchar,lvarchar)" returnType="varchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="java"><![CDATA[create dba procedure sqlj.alter_java_path(varchar(255), lvarchar)
external name 'informix.jvp.dbapplet.impl.JarHandler.alterJavaPath(java.lang.String, java.lang.String)' language java end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="assign(blob)" returnType="blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.assign(informix.blob)
	returns informix.blob
	external name '(blob_assign)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="assign(bson)" returnType="bson" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.assign(bson) returns bson
external name '(bson_assign)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="assign(clob)" returnType="clob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.assign(informix.clob)
	returns informix.clob
	external name '(clob_assign)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="assign(json)" returnType="json" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.assign(json) returns json
external name '(json_assign)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="assign(list)" returnType="list" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.assign(list) returns list
	external name '(collectionassign)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="assign(longlvarchar)" returnType="longlvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.assign(longlvarchar) returns longlvarchar
external name '(llvc_assign)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="assign(multiset)" returnType="multiset" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.assign(multiset) returns multiset
	external name '(collectionassign)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="assign(row)" returnType="row" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.assign(row) returns row
	external name '(rowassign)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="assign(set)" returnType="set" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.assign(set) returns set
	external name '(collectionassign)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="assign(stat)" returnType="stat" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.assign(informix.stat)
       returns informix.stat
       external name '(stat_assign)'
       language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="blobexport(blob)" returnType="blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.blobexport(informix.blob)
	returns informix.impexp
	external name '(blob_export)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="blobimport(impexp)" returnType="impexp" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.blobimport(informix.impexp)
	returns informix.blob
	external name '(blob_import)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="blobinput(lvarchar)" returnType="lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- blob and clob support functions with informix.their associated casts

create dba function informix.blobinput(informix.lvarchar) returns informix.blob
	external name '(blob_input)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="bloboutput(blob)" returnType="blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.bloboutput(informix.blob) returns informix.lvarchar
	external name '(blob_output)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="blobrecv(sendrecv)" returnType="sendrecv" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.blobrecv(informix.sendrecv)
	returns informix.blob
	external name '(blob_recv)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="blobsend(blob)" returnType="blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.blobsend(informix.blob) returns informix.sendrecv
	external name '(blob_send)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="bson_explain(lvarchar)" returnType="lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.bson_explain(informix.lvarchar)
    returns bson
    external name '(bson_sqexplain_single_statement)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="bson_export_bin(bson)" returnType="bson" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.bson_export_bin(bson) returns impexpbin
with (not variant, parallelizable)
external name '(bson_export_bin)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="bson_export_txt(bson)" returnType="bson" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.bson_export_txt(bson) returns impexp
with (not variant, parallelizable)
external name '(bson_export_txt)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="bson_extract(bson,lvarchar)" returnType="bson,lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.bson_extract(informix.bson, informix.lvarchar)
returns informix.bson
external name '(bson_extract)' language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="bson_import_bin(impexpbin)" returnType="impexpbin" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.bson_import_bin(impexpbin) returns bson
with (not variant, parallelizable)
external name '(bson_import_bin)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="bson_import_txt(impexp)" returnType="impexp" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.bson_import_txt(impexp) returns bson
with (not variant, parallelizable)
external name '(bson_import_txt)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="bson_in(lvarchar)" returnType="lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.bson_in(lvarchar) returns bson
with (not variant, parallelizable)
external name '(bson_input)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="bson_out(bson)" returnType="bson" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.bson_out(bson) returns lvarchar
with  (not variant, parallelizable)
external name '(bson_output)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="bson_recv(sendrecv)" returnType="sendrecv" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.bson_recv(sendrecv) returns bson
with  (not variant, parallelizable)
external name '(bson_recv)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="bson_send(bson)" returnType="bson" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.bson_send(bson) returns sendrecv
with (not variant, parallelizable)
external name '(bson_send)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="bson_valid(bson)" returnType="bson" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.bson_valid(informix.bson) returning informix.lvarchar
external name '(bson_valid)'
language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="bytetoblob(references byte)" returnType="references byte" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- cast from byte to blob

create function informix.bytetoblob(references byte)
	returns informix.blob
	external name '(bytetoblob)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="bytetoblob(references byte,char,char)" returnType="references byte,char,char" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.bytetoblob(references byte, char(128), char(128))
        returns informix.blob
        external name '(bytetoblob_colspec)'
        language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="bytetoblob_pre1150(references byte,char,char)" returnType="references byte,char,char" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.bytetoblob(references byte, char(18), char(18))
	returns informix.blob
	external name '(bytetoblob_colspec)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="cdrcmd(integer)" returnType="integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.cdrcmd(informix.integer)
    returns informix.integer
    external name '(cdrcmd_1)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="cdrcmd(integer,integer)" returnType="integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.cdrcmd(informix.integer, informix.integer)
    returns informix.integer
    external name '(cdrcmd_2)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="cdrcmd(integer,integer,integer)" returnType="integer,integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.cdrcmd(informix.integer, informix.integer, informix.integer)
    returns informix.integer
    external name '(cdrcmd_3)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="cdrcmd(integer,lvarchar)" returnType="integer,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.cdrcmd(informix.integer, informix.lvarchar)
    returns informix.integer
    external name '(cdrcmd_4)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="cdrcmd_get(integer)" returnType="integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.cdrcmd_get(informix.integer)
    returns informix.lvarchar
    external name '(cdrcmd_get)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="cdrcmdfl(integer)" returnType="integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.cdrcmdfl(informix.integer)
    returns informix.float
    external name '(cdrcmdfl_1)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="cdrcmdlv(integer,integer,integer)" returnType="integer,integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.cdrcmdLV(informix.integer, informix.integer,
	        informix.integer)
    returns informix.lvarchar
    external name '(cdrcmdLV_3)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="cdrcmdproc(integer)" returnType="integer" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.cdrcmdproc(informix.integer)
    external name '(cdrcmd_1)'
    language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="cdrgcdisp(lvarchar)" returnType="lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.cdrgcdisp(informix.lvarchar)
    returns informix.lvarchar
    external name '(sqcdrGC2Disp)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="clientbinval_recv(sendrecv)" returnType="sendrecv" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.clientbinval_recv(informix.sendrecv)
    returns informix.clientbinval
    external name '(mife_clientbinval_recv)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="clientbinval_send(clientbinval)" returnType="clientbinval" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.clientbinval_send(informix.clientbinval)
    returns informix.sendrecv
    external name '(mife_clientbinval_send)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="clobexport(clob)" returnType="clob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.clobexport(informix.clob)
	returns informix.impexp
	external name '(clob_export)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="clobimport(impexp)" returnType="impexp" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.clobimport(informix.impexp)
	returns informix.clob
	external name '(clob_import)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="clobinput(lvarchar)" returnType="lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.clobinput(informix.lvarchar) returns informix.clob
	external name '(clob_input)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="cloboutput(clob)" returnType="clob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.cloboutput(informix.clob) returns informix.lvarchar
	external name '(clob_output)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="clobrecv(sendrecv)" returnType="sendrecv" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.clobrecv(informix.sendrecv)
	returns informix.clob
	external name '(clob_recv)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="clobsend(clob)" returnType="clob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.clobsend(informix.clob) returns informix.sendrecv
	external name '(clob_send)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="collcast(collection)" returnType="collection" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- cast functions for untyped collection
create dba function informix.collcast(collection) returns collection
        external name '(collcast)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="collcast(list)" returnType="list" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.collcast(list) returns list
        external name '(collcast)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="collcast(multiset)" returnType="multiset" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.collcast(multiset) returns multiset
        external name '(collcast)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="collcast(set)" returnType="set" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- cast function definitions
create dba function informix.collcast(set) returns set
        external name '(collcast)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="collectionexport(collection)" returnType="collection" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.collectionexport(collection) returns informix.impexp
        external name '(collectionexport)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="collectionexport(list)" returnType="list" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.collectionexport(list) returns informix.impexp
        external name '(collectionexport)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="collectionexport(multiset)" returnType="multiset" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.collectionexport(multiset) returns informix.impexp
        external name '(collectionexport)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="collectionexport(set)" returnType="set" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.collectionexport(set) returns informix.impexp
        external name '(collectionexport)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="collectionimport(impexp)" returnType="impexp" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- add collectionimport and collectionexport functions
create dba function informix.collectionimport(informix.impexp) returns set
        external name '(collectionimport)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="collectioninput(lvarchar)" returnType="lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.collectioninput(informix.lvarchar) returns set
        external name '(collectioninput)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="collectionoutput(collection)" returnType="collection" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.collectionoutput(collection)
	returns informix.lvarchar
        external name '(collectionoutput)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="collectionoutput(list)" returnType="list" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.collectionoutput(list) returns informix.lvarchar
        external name '(collectionoutput)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="collectionoutput(multiset)" returnType="multiset" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.collectionoutput(multiset) returns informix.lvarchar
        external name '(collectionoutput)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="collectionoutput(set)" returnType="set" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- Collection function definitions
create dba function informix.collectionoutput(set) returns informix.lvarchar
        external name '(collectionoutput)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="collectionrecv(sendrecv)" returnType="sendrecv" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- Send/recv Collection Functions
create dba function informix.collectionrecv(informix.sendrecv) returns set
        external name '(collectionrecv)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="collectionsend(collection)" returnType="collection" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[---Add new collectionsend() to handle all collection types
create dba function informix.collectionsend(collection)
        returns informix.sendrecv
        external name '(collectionsend)'
        language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="comb_aggrelem(pointer,pointer)" returnType="pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.comb_aggrelem(informix.pointer,informix.pointer)
returns informix.pointer
external name '(comb_aggrelem)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="comb_aggrelemc(pointer,pointer)" returnType="pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.comb_aggrelemc(informix.pointer,informix.pointer)
returns  informix.pointer
external name '(comb_aggrelemc)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="comb_aggrschema(pointer,pointer)" returnType="pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.comb_aggrschema(informix.pointer,informix.pointer)
returns informix.pointer
external name '(comb_aggrschema)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="comb_aggrschemac(pointer,pointer)" returnType="pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.comb_aggrschemac(informix.pointer,informix.pointer)
returns  informix.pointer
external name '(comb_aggrschemac)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="comb_aggrxml(pointer,pointer)" returnType="pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.comb_aggrxml(informix.pointer,informix.pointer)
returns  informix.pointer
external name '(comb_aggrxml)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="comb_aggrxmlc(pointer,pointer)" returnType="pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.comb_aggrxmlc(informix.pointer,informix.pointer)
returns  informix.pointer
external name '(comb_aggrxmlc)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="compare(bson,bson)" returnType="bson,bson" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.compare(informix.bson, informix.bson)
returns integer
external name '(bson_cmpr)' language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="compare(json,json)" returnType="json,json" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.compare(informix.json, informix.json)
returns integer
external name '(json_cmp)' language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="compare(longlvarchar,longlvarchar)" returnType="longlvarchar,longlvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.compare(informix.longlvarchar, informix.longlvarchar)
returns integer
external name '(llvc_cmp)' language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="coveringinfoinput(lvarchar)" returnType="lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.CoveringinfoInput(informix.lvarchar)
    returns informix.IDSCOVERINGINFO
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(coveringinfo_in)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="coveringinfooutput(idscoveringinfo)" returnType="idscoveringinfo" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.CoveringinfoOutput(informix.IDSCOVERINGINFO)
    returns informix.lvarchar
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(coveringinfo_out)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="dbg_endsessionmanager(varchar,integer,out blob)" returnType="varchar,integer,out blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function SYSPROC.DBG_EndSessionManager(
		host_ip varchar(128),
		port integer,
		OUT xml_reply blob)
    returns integer
    external name '(DBG_EndSessionManager)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="dbg_initializeclient(varchar,integer,blob,out blob)" returnType="varchar,integer,blob,out blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function SYSPROC.DBG_InitializeClient(
		host_ip varchar(128),
		port integer,
		xml_request blob,
		OUT xml_reply blob)
    returns integer
    external name '(DBG_InitializeClient)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="dbg_lookupsessionmanager(out varchar,out integer)" returnType="out varchar,out integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function SYSPROC.DBG_LookupSessionManager(
		OUT host_ip varchar(128),
		OUT port integer)
    returns integer
    external name '(DBG_LookupSessionManager)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="dbg_pingsessionmanager(varchar,integer,out blob)" returnType="varchar,integer,out blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function SYSPROC.DBG_PingSessionManager(
		host_ip varchar(128),
		port integer,
		OUT xml_reply blob)
    returns integer
    external name '(DBG_PingSessionManager)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="dbg_recvclientreports(varchar,integer,blob,out blob,out blob,out blob)" returnType="varchar,integer,blob,out blob,out blob,out blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function SYSPROC.DBG_RecvClientReports(
		host_ip varchar(128),
		port integer,
		xml_request blob,
		OUT xml_reply blob,
		OUT xml_data blob,
		OUT bin_data blob)
    returns integer
    external name '(DBG_RecvClientReports)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="dbg_runsessionmanager(integer,integer,out blob)" returnType="integer,integer,out blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function SYSPROC.DBG_RunSessionManager(
		port integer,
		idle_timeout integer,
		OUT xml_reply blob)
    returns integer
    external name '(DBG_RunSessionManager)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="dbg_sendclientcommands(varchar,integer,blob,blob,blob,out blob)" returnType="varchar,integer,blob,blob,blob,out blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function SYSPROC.DBG_SendClientCommands(
		host_ip varchar(128),
		port integer,
		xml_request blob,
		xml_data blob,
		bin_data blob,
		OUT xml_reply blob)
    returns integer
    external name '(DBG_SendClientCommands)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="dbg_sendclientrequests(varchar,integer,blob,out blob)" returnType="varchar,integer,blob,out blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function SYSPROC.DBG_SendClientRequests(
		host_ip varchar(128),
		port integer,
		xml_request blob,
		OUT xml_reply blob)
    returns integer
    external name '(DBG_SendClientRequests)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="dbg_terminateclient(varchar,integer,blob,out blob)" returnType="varchar,integer,blob,out blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function SYSPROC.DBG_TerminateClient(
		host_ip varchar(128),
		port integer,
		xml_request blob,
		OUT xml_reply blob)
    returns integer
    external name '(DBG_TerminateClient)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="deepcopy(bson)" returnType="bson" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.deepcopy(bson) returns bson
external name '(bson_deep_copy)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="deepcopy(json)" returnType="json" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.deepcopy(json) returns json
external name '(json_deep_copy)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="deepcopy(list)" returnType="list" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.deepcopy(list) returns list
        external name '(collectiondeepcopy)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="deepcopy(longlvarchar)" returnType="longlvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.deepcopy(longlvarchar) returns longlvarchar
external name '(llvc_deep_copy)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="deepcopy(multiset)" returnType="multiset" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.deepcopy(multiset) returns multiset
        external name '(collectiondeepcopy)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="deepcopy(row)" returnType="row" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.deepcopy(row) returns row
        external name '(rowdeepcopy)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="deepcopy(set)" returnType="set" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.deepcopy(set) returns set
        external name '(collectiondeepcopy)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="destroy(blob)" returnType="blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.destroy(informix.blob)
	returns informix.blob
	external name '(blob_destroy)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="destroy(bson)" returnType="bson" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.destroy(bson)
external name '(bson_type_destroy)' language c
end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="destroy(clob)" returnType="clob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.destroy(informix.clob)
	returns informix.clob
	external name '(clob_destroy)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="destroy(json)" returnType="json" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.destroy(json)
external name '(json_type_destroy)' language c
end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="destroy(list)" returnType="list" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.destroy(list) returns list
	external name '(collectiondestroy)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="destroy(longlvarchar)" returnType="longlvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.destroy(longlvarchar)
external name '(llvc_destroy)' language c
end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="destroy(multiset)" returnType="multiset" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.destroy(multiset) returns multiset
	external name '(collectiondestroy)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="destroy(row)" returnType="row" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.destroy(row) returns row
	external name '(rowdestroy)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="destroy(set)" returnType="set" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.destroy(set) returns set
	external name '(collectiondestroy)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="destroy(stat)" returnType="stat" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.destroy(informix.stat)
       returns informix.stat
       external name '(stat_destroy)'
       language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="dosyscast(pointer,integer,integer)" returnType="pointer,integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.dosyscast(informix.pointer, int, int)
	returning informix.pointer
	external name '(dosyscast)'
	language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="dummyproc_1150xc6()" returnType="" securityType="Owner" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="spl"><![CDATA[create procedure informix.dummyproc_1150XC6()
end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="dummyproc_1170()" returnType="" securityType="Owner" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="spl"><![CDATA[create procedure informix.dummyproc_1170()
end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="dummyproc_1210()" returnType="" securityType="Owner" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="spl"><![CDATA[create procedure informix.dummyproc_1210()
end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="dummyproc_1210xc4()" returnType="" securityType="Owner" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="spl"><![CDATA[create procedure informix.dummyproc_1210XC4()
end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="elementenc_to_decimal(idselementenc)" returnType="idselementenc" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.ELEMENTENC_TO_DECIMAL(informix.IDSELEMENTENC)
    returns informix.decimal
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(ifx_elementenc_to_decimal)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="elementencinput(lvarchar)" returnType="lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.ElementencInput(informix.lvarchar)
    returns informix.IDSELEMENTENC
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(elementenc_in)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="elementencoutput(idselementenc)" returnType="idselementenc" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.ElementencOutput(informix.IDSELEMENTENC)
    returns informix.lvarchar
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(elementenc_out)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="equal(json,json)" returnType="json,json" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.equal(informix.json, informix.json)
returns informix.boolean
external name '(json_eq)' language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="equal(longlvarchar,longlvarchar)" returnType="longlvarchar,longlvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.equal(informix.longlvarchar, informix.longlvarchar)
returns informix.boolean
external name '(llvc_eq)' language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="existsnode(clob,lvarchar)" returnType="clob,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.existsnode(informix.clob,informix.lvarchar)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
          PERCALL_COST = 32768 )
    external name '$INFORMIXDIR/lib/libxml.udr(xmlexistnodeinputclob)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="existsnode(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.existsnode(informix.lvarchar,informix.lvarchar)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
          PERCALL_COST = 32768 )
    external name '$INFORMIXDIR/lib/libxml.udr(xmlexistnode)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="explain_sql(inout integer,inout integer,varchar,blob,blob,out blob,out blob)" returnType="inout integer,inout integer,varchar,blob,blob,out blob,out blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.explain_sql(INOUT major_version int,
                                     INOUT minor_version int,
                                     requested_locale varchar(33),
                                     xml_input blob,
                                     xml_filter blob,
                                     OUT xml_output blob,
                                     OUT xml_message blob)
returns blob as xml_plan
with (HANDLESNULLS)
external name '(explain_sql)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="extract(clob,lvarchar)" returnType="clob,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.extract(informix.clob,informix.lvarchar)
    returns informix.lvarchar(32739)
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
          PERCALL_COST = 32768 )
    external name '$INFORMIXDIR/lib/libxml.udr(xmlextractinputclob)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="extract(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.extract(informix.lvarchar,informix.lvarchar)
    returns informix.lvarchar(32739)
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
          PERCALL_COST = 32768 )
    external name '$INFORMIXDIR/lib/libxml.udr(xmlextract)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="extractclob(clob,lvarchar)" returnType="clob,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.extractclob(informix.clob,informix.lvarchar)
    returns informix.clob
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
          PERCALL_COST = 32768 )
    external name '$INFORMIXDIR/lib/libxml.udr(xmlextractclob)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="extractvalue(clob,lvarchar)" returnType="clob,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.extractvalue(informix.clob,informix.lvarchar)
    returns informix.lvarchar(32739)
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
          PERCALL_COST = 32768 )
    external name '$INFORMIXDIR/lib/libxml.udr(xmlextractvalueinputclob)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="extractvalue(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.extractvalue(informix.lvarchar,informix.lvarchar)
    returns informix.lvarchar(32739)
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
          PERCALL_COST = 32768 )
    external name '$INFORMIXDIR/lib/libxml.udr(xmlextractvalue)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="extractvalueclob(clob,lvarchar)" returnType="clob,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.extractvalueclob(informix.clob,informix.lvarchar)
    returns informix.clob
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
          PERCALL_COST = 32768 )
    external name '$INFORMIXDIR/lib/libxml.udr(xmlextractvalueclob)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="filetoblob(lvarchar,char)" returnType="lvarchar,char" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- blob and clob user functions

create dba function informix.filetoblob(informix.lvarchar, char(6))
	returns informix.blob
	external name '(blob_from_file)'
	language c variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="filetoblob(lvarchar,char,char,char)" returnType="lvarchar,char,char,char" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.filetoblob(informix.lvarchar, char(6), char(128), char(128))
	returns informix.blob
        with (handlesnulls)
	external name '(blob_from_file_colspec)'
	language c variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="filetoblobpre1170(lvarchar,char,char,char)" returnType="lvarchar,char,char,char" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.filetoblob(informix.lvarchar, char(6), char(18), char(18))
	returns informix.blob
	external name '(blob_from_file_colspec)'
	language c variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="filetoclob(lvarchar,char)" returnType="lvarchar,char" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.filetoclob(informix.lvarchar, char(6))
	returns informix.clob
	external name '(blob_from_file)' -- yes blob_from_file
	language c variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="filetoclob(lvarchar,char,char,char)" returnType="lvarchar,char,char,char" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.filetoclob(informix.lvarchar, char(6), char(128), char(128))
	returns informix.clob
        with (handlesnulls)
	external name '(blob_from_file_colspec)'
	language c variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="filetoclobpre1170(lvarchar,char,char,char)" returnType="lvarchar,char,char,char" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.filetoclob(informix.lvarchar, char(6), char(18), char(18))
	returns informix.clob
	external name '(blob_from_file_colspec)'
	language c variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="final_aggrelem(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.final_aggrelem(informix.pointer)
returns  informix.lvarchar(32739)
external name '(final_aggrelem)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="final_aggrelemc(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.final_aggrelemc(informix.pointer)
returns  informix.clob
external name '(final_aggrelemc)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="final_aggrschema(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.final_aggrschema(informix.pointer)
returns  informix.lvarchar(32739)
external name '(final_aggrschema)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="final_aggrschemac(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.final_aggrschemac(informix.pointer)
returns  informix.clob
external name '(final_aggrschemac)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="final_aggrxml(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.final_aggrxml(informix.pointer)
returns  informix.lvarchar(32739)
external name '(final_aggrxml)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="final_aggrxmlc(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.final_aggrxmlc(informix.pointer)
returns  informix.clob
external name '(final_aggrxmlc)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="genbson(row,integer,integer)" returnType="row,integer,integer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.genbson(informix.ROW, informix.integer DEFAULT 0,
                        informix.integer DEFAULT 0)
    returns bson
    external name '(genBSON)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="genxmlquery(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.genxmlquery(informix.LVARCHAR, informix.lvarchar)
returns informix.lvarchar(32739)
with(NOT VARIANT)
external name '(genxmlquery)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="genxmlqueryclob(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.genxmlqueryclob(informix.LVARCHAR, informix.LVARCHAR)
returns informix.clob
with(NOT VARIANT)
external name '(genxmlqueryclob)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="genxmlqueryhdr(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.genxmlqueryhdr(informix.LVARCHAR, informix.LVARCHAR)
returns informix.lvarchar(32739)
with(NOT VARIANT)
external name '(genxmlqueryhdr)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="genxmlqueryhdrclob(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.genxmlqueryhdrclob(informix.LVARCHAR, informix.LVARCHAR)
returns informix.clob
with(NOT VARIANT)
external name '(genxmlqueryhdrclob)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="get_cursor_table(lvarchar)" returnType="lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.get_cursor_table(lvarchar)
    returns lvarchar
    external name '(mi_get_cursor_table)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="get_data_type(smallint,integer,smallint)" returnType="smallint,integer,smallint" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.get_data_type(coltype smallint, xtype integer, is_odbc smallint)
returning smallint
external name '(get_data_type)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="get_default_value(smallint,smallint,integer,lvarchar)" returnType="smallint,smallint,integer,lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.get_default_value(coltype smallint, colxid smallint, collen integer, defstr lvarchar(256))
returning lvarchar(256)
external name '(get_default_value)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="gist_beginscan(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.gist_beginscan(informix.pointer)
    returns integer
    with (parallelizable)
    external name '(gist_beginscan)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="gist_check(pointer,integer)" returnType="pointer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.gist_check(informix.pointer, integer)
    returns real
    external name '(gist_check)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="gist_close(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.gist_close(informix.pointer)
    returns integer
    with (parallelizable)
    external name '(gist_close)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="gist_cost(pointer,pointer)" returnType="pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- no gist_stats

create dba function informix.gist_cost(informix.pointer, informix.pointer)
    returns real
    external name '(gist_cost)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="gist_create(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- Define gist access method

create dba function informix.gist_create(informix.pointer)
    returns integer
    with (parallelizable)
    external name '(gist_create)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="gist_delete(pointer,pointer,pointer)" returnType="pointer,pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.gist_delete(informix.pointer, informix.pointer, informix.pointer)
    returns integer
    with (parallelizable)
    external name '(gist_delete)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="gist_drop(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.gist_drop(informix.pointer)
    returns integer
    with (parallelizable)
    external name '(gist_drop)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="gist_endscan(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.gist_endscan(informix.pointer)
    returns integer
    with (parallelizable)
    external name '(gist_endscan)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="gist_getnext(pointer,pointer,pointer)" returnType="pointer,pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.gist_getnext(informix.pointer, informix.pointer, informix.pointer)
    returns integer
    with (parallelizable)
    external name '(gist_getnext)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="gist_insert(pointer,pointer,pointer)" returnType="pointer,pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.gist_insert(informix.pointer, informix.pointer, informix.pointer)
    returns integer
    with (parallelizable)
    external name '(gist_insert)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="gist_open(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.gist_open(informix.pointer)
    returns integer
    with (parallelizable)
    external name '(gist_open)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="gist_redo(pointer,pointer,integer,integer)" returnType="pointer,pointer,integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- Define recovery related functions for the gist access method:

create dba function informix.gist_redo(informix.pointer, informix.pointer, integer, integer)
    returns integer
    external name '(gist_redo)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="gist_rescan(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.gist_rescan(informix.pointer)
    returns integer
    with (parallelizable)
    external name '(gist_rescan)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="gist_undo(pointer,pointer,integer,integer)" returnType="pointer,pointer,integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.gist_undo(informix.pointer, informix.pointer, integer, integer)
    returns integer
    external name '(gist_undo)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="gist_update(pointer,pointer,pointer,pointer,pointer)" returnType="pointer,pointer,pointer,pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.gist_update(informix.pointer, informix.pointer, informix.pointer, informix.pointer, informix.pointer)
    returns integer
    with (parallelizable)
    external name '(gist_update)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="greaterthan(longlvarchar,longlvarchar)" returnType="longlvarchar,longlvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.greaterthan(informix.longlvarchar, informix.longlvarchar)
returns informix.boolean
external name '(llvc_gt)' language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="greaterthanorequal(longlvarchar,longlvarchar)" returnType="longlvarchar,longlvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.greaterthanorequal(informix.longlvarchar, informix.longlvarchar)
returns informix.boolean
external name '(llvc_ge)' language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="idsxmlparse(clob)" returnType="clob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.idsxmlparse(informix.clob)
    returns informix.clob
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
          PERCALL_COST = 32768 )
    external name '$INFORMIXDIR/lib/libxml.udr(xmlparseclob)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="idsxmlparse(lvarchar)" returnType="lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.idsxmlparse(informix.lvarchar)
    returns informix.lvarchar(32739)
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
          PERCALL_COST = 32768 )
    external name '$INFORMIXDIR/lib/libxml.udr(xmlparse)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_allow_newline(boolean)" returnType="boolean" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_allow_newline (informix.boolean);
external name '' language C
end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_bit_leftshift(bigint,integer)" returnType="bigint,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function
    informix.ifx_bit_leftShift(informix.bigint, integer)
    returns informix.bigint
    external name '(ifx_bit_leftShift2)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_bit_leftshift(integer,integer)" returnType="integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function
    informix.ifx_bit_leftshift(integer, integer)
    returns integer
    external name '(ifx_bit_leftShift1)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_bit_rightshift(bigint,integer)" returnType="bigint,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function
    informix.ifx_bit_rightShift(informix.bigint, integer)
    returns informix.bigint
    external name '(ifx_bit_rightShift2)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_bit_rightshift(integer,integer)" returnType="integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function
    informix.ifx_bit_rightshift(integer, integer)
    returns integer
    external name '(ifx_bit_rightShift1)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(bigint,integer)" returnType="bigint,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(informix.bigint, informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(bigint_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(blob,integer)" returnType="blob,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(informix.blob, informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(sblob_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(clob,integer)" returnType="clob,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(informix.clob, informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(sblob_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(date,integer)" returnType="date,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(informix.date, informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(date_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(datetime,integer)" returnType="datetime,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(datetime year to fraction, informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(datetime_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(decimal,integer)" returnType="decimal,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(informix.decimal, informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(decimal_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(float,integer)" returnType="float,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(informix.float, informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(double_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(int8,integer)" returnType="int8,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(informix.int8, informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(int8_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(integer,integer)" returnType="integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(informix.integer, informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(integer_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(interval,integer)" returnType="interval,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(interval year to month,informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(interval_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(list,integer)" returnType="list,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(list, informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(collection_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(lvarchar,integer)" returnType="lvarchar,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(informix.lvarchar, informix.integer)
 returns informix.integer
 with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
 external name '(lvarchar_checksum)'
 language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(money,integer)" returnType="money,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(informix.money, informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(money_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(multiset,integer)" returnType="multiset,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(informix.multiset, informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(collection_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(references byte,integer)" returnType="references byte,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(p1 references byte,informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(classicBlob_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(references text,integer)" returnType="references text,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(p1 references text,informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(classicBlob_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(row,integer)" returnType="row,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(informix.row, informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(row_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(set,integer)" returnType="set,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(informix.set, informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(collection_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(smallfloat,integer)" returnType="smallfloat,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(informix.real, informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(real_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_checksum(smallint,integer)" returnType="smallint,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_checksum(informix.smallint, informix.integer)
    returns informix.integer
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(short_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_collection_create(lvarchar,lvarchar,lvarchar)" returnType="lvarchar,lvarchar,lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.ifx_Collection_Create(informix.lvarchar,
      informix.lvarchar, informix.lvarchar default NULL)
      returning integer
      with (handlesnulls)
      external name '(json_collection_create)'
      language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_collection_drop(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.ifx_Collection_Drop( informix.lvarchar,
      informix.lvarchar default NULL)
      returning integer
      with (handlesnulls)
      external name '(json_collection_drop)'
      language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_collection_index_create(lvarchar,lvarchar,lvarchar,lvarchar,lvarchar,integer,lvarchar)" returnType="lvarchar,lvarchar,lvarchar,lvarchar,lvarchar,integer,lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.ifx_Collection_Index_Create(
      informix.lvarchar, informix.lvarchar,
      informix.lvarchar, informix.lvarchar, informix.lvarchar,
      informix.INTEGER DEFAULT 0, informix.lvarchar DEFAULT NULL)
      returning integer
      with (handlesnulls)
      external name '(json_collection_index_create)'
      language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_collection_index_drop(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.ifx_Collection_Index_Drop(
      informix.lvarchar, informix.lvarchar default NULL)
      returning integer
      with (handlesnulls)
      external name '(json_collection_index_drop)'
      language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_explain(lvarchar)" returnType="lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.ifx_explain(informix.lvarchar)
    returns lvarchar
    external name '(sql_sqexplain_single_statement)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_file_checksum(lvarchar)" returnType="lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function
    informix.ifx_file_checksum(informix.lvarchar)
    returns integer
    external name '(ifx_get_file_checksum)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_file_to_file(lvarchar,integer,lvarchar,integer)" returnType="lvarchar,integer,lvarchar,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_file_to_file(informix.lvarchar, int, informix.lvarchar, int)
	returns informix.lvarchar
	external name '(sq_file_to_file)'
	language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_get_erstate()" returnType="" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_get_erstate()
    returns integer
    external name '(ifx_get_erstate)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_connect(lvarchar)" returnType="lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_grid_connect(informix.lvarchar)
  with (handlesnulls,parallelizable)
  external name '(grid_connect1)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_connect(lvarchar,integer)" returnType="lvarchar,integer" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure
  informix.ifx_grid_connect(
    informix.lvarchar,
    informix.integer)
  with (handlesnulls,parallelizable)
  external name '(grid_connect4)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_connect(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure
  informix.ifx_grid_connect(
    informix.lvarchar,
    informix.lvarchar)
  with (handlesnulls,parallelizable)
  external name '(grid_connect2)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_connect(lvarchar,lvarchar,integer)" returnType="lvarchar,lvarchar,integer" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure
  informix.ifx_grid_connect(
    informix.lvarchar,
    informix.lvarchar,
    informix.integer)
  with (handlesnulls,parallelizable)
  external name '(grid_connect3)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_copy(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure
    informix.ifx_grid_copy(
            informix.lvarchar,
            informix.lvarchar)
    with (handlesnulls)
    external name '(grid_copy1)'
    language C
    end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_copy(lvarchar,lvarchar,lvarchar)" returnType="lvarchar,lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure
    informix.ifx_grid_copy(
            informix.lvarchar,
            informix.lvarchar,
            informix.lvarchar)
    with (handlesnulls)
    external name '(grid_copy2)'
    language C
    end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_copy(lvarchar,lvarchar,lvarchar,lvarchar)" returnType="lvarchar,lvarchar,lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure
    informix.ifx_grid_copy(
            informix.lvarchar,
            informix.lvarchar,
            informix.lvarchar,
            informix.lvarchar)
    with (handlesnulls)
    external name '(grid_copy3)'
    language C
    end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_disconnect()" returnType="" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure
  informix.ifx_grid_disconnect()
  with (handlesnulls, parallelizable)
  external name '(grid_disconnect)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_execute(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure
  informix.ifx_grid_execute(
        informix.lvarchar,
        informix.lvarchar)
  with (handlesnulls)
  external name '(grid_execute2)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_execute(lvarchar,lvarchar,lvarchar)" returnType="lvarchar,lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure
  informix.ifx_grid_execute(
        informix.lvarchar,
        informix.lvarchar,
        informix.lvarchar)
  with (handlesnulls)
  external name '(grid_execute3)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_executecmd()" returnType="" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_grid_executecmd()
    with (handlesnulls)
    external name '(grid_executeCmd)'
    language C
    end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_function(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_grid_function(
        informix.lvarchar,
        informix.lvarchar)
  returns lvarchar(30000)
  with (handlesnulls)
  external name '(grid_function2)'
  language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_function(lvarchar,lvarchar,lvarchar)" returnType="lvarchar,lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_grid_function(
        informix.lvarchar,
        informix.lvarchar,
        informix.lvarchar)
  returns lvarchar(30000)
  with (handlesnulls)
  external name '(grid_function3)'
  language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_procedure(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure
  informix.ifx_grid_procedure(
        informix.lvarchar,
        informix.lvarchar)
  with (handlesnulls)
  external name '(grid_procedure2)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_procedure(lvarchar,lvarchar,lvarchar)" returnType="lvarchar,lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure
  informix.ifx_grid_procedure(
        informix.lvarchar,
        informix.lvarchar,
        informix.lvarchar)
  with (handlesnulls)
  external name '(grid_procedure3)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_purge()" returnType="" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_grid_purge()
  external name '(grid_purge0)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_purge(lvarchar)" returnType="lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_grid_purge(
    informix.lvarchar)
  with (handlesnulls)
  external name '(grid_purge1)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_purge(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_grid_purge(
    informix.lvarchar,
    informix.lvarchar)
  with (handlesnulls)
  external name '(grid_purge2)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_purge(lvarchar,lvarchar,lvarchar)" returnType="lvarchar,lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_grid_purge(
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar)
  with (handlesnulls)
  external name '(grid_purge3)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_purge(lvarchar,lvarchar,lvarchar,lvarchar)" returnType="lvarchar,lvarchar,lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_grid_purge(
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar)
  with (handlesnulls)
  external name '(grid_purge4)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_purge(lvarchar,lvarchar,lvarchar,lvarchar,lvarchar)" returnType="lvarchar,lvarchar,lvarchar,lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_grid_purge(
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar)
  with (handlesnulls)
  external name '(grid_purge5)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_purge(lvarchar,lvarchar,lvarchar,lvarchar,lvarchar,lvarchar)" returnType="lvarchar,lvarchar,lvarchar,lvarchar,lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_grid_purge(
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar)
  with (handlesnulls)
  external name '(grid_purge6)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_redo()" returnType="" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_grid_redo()
  external name '(grid_redo0)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_redo(lvarchar)" returnType="lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_grid_redo(
    informix.lvarchar)
  with (handlesnulls)
  external name '(grid_redo1)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_redo(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_grid_redo(
    informix.lvarchar,
    informix.lvarchar)
  with (handlesnulls)
  external name '(grid_redo2)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_redo(lvarchar,lvarchar,lvarchar)" returnType="lvarchar,lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_grid_redo(
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar)
  with (handlesnulls)
  external name '(grid_redo3)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_redo(lvarchar,lvarchar,lvarchar,lvarchar)" returnType="lvarchar,lvarchar,lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_grid_redo(
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar)
  with (handlesnulls)
  external name '(grid_redo4)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_redo(lvarchar,lvarchar,lvarchar,lvarchar,lvarchar)" returnType="lvarchar,lvarchar,lvarchar,lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_grid_redo(
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar)
  with (handlesnulls)
  external name '(grid_redo5)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_redo(lvarchar,lvarchar,lvarchar,lvarchar,lvarchar,lvarchar)" returnType="lvarchar,lvarchar,lvarchar,lvarchar,lvarchar,lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_grid_redo(
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar,
    informix.lvarchar)
  with (handlesnulls)
  external name '(grid_redo6)'
  language C
  end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_release(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_grid_release(
                    informix.lvarchar, informix.lvarchar)
    returns integer
    external name '(ifx_grid_release)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_grid_remove(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_grid_remove(
                    informix.lvarchar, informix.lvarchar)
    returns integer
    external name '(ifx_grid_remove)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_gridquery_skipped_node_count()" returnType="" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_gridquery_skipped_node_count()
    returns integer
    external name '(gridQueryGetSkippedNodeCount)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_gridquery_skipped_nodes()" returnType="" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_gridquery_skipped_nodes()
    returns informix.lvarchar
    external name '(gridQueryGetSkippedNode)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_invalid_module(varchar,varchar)" returnType="varchar,varchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_invalid_module(varchar(255), varchar(255))
        returns int
        external name '' language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_lo_alter(blob,ifx_lo_spec)" returnType="blob,ifx_lo_spec" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_lo_alter(informix.blob, informix.ifx_lo_spec)
	returns integer
	external name '(sq_lo_alter)'
	language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_lo_close(integer)" returnType="integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_lo_close(integer)
	returns integer
	external name '(sq_lo_close)'
	language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_lo_col_sbinfo(lvarchar,out ifx_lo_spec)" returnType="lvarchar,out ifx_lo_spec" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_lo_col_sbinfo(informix.lvarchar, out informix.ifx_lo_spec)
	returns integer
	external name '(sq_lo_col_sblobinfo_by_colname)'
	language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_lo_create(ifx_lo_spec,integer,out blob)" returnType="ifx_lo_spec,integer,out blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- fastpath entry points to support client sblob I/O
create dba function informix.ifx_lo_create(ifx_lo_spec, integer, out informix.blob)
	returns integer
	external name '(sq_lo_create)'
	language c           -- this is variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_lo_filename(blob,lvarchar)" returnType="blob,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_lo_filename(informix.blob, informix.lvarchar)
	returns informix.lvarchar
	external name '(sq_lo_filename)'
	language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_lo_from_file(integer,lvarchar,integer,integer,integer)" returnType="integer,lvarchar,integer,integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_lo_from_file(int, informix.lvarchar, int, int, int)
	returns integer
	external name '(sq_lo_from_file)'
	language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_lo_lock(integer,int8,integer,int8,integer)" returnType="integer,int8,integer,int8,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- fastpath entry points to support client sblob range locking

create dba function informix.ifx_lo_lock(integer, int8, integer, int8, integer)
	returns integer
	external name '(sq_lo_lock)'
	language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_lo_open(blob,integer)" returnType="blob,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_lo_open(informix.blob, integer)
	returns integer
	external name '(sq_lo_open)'
	language c           -- this is variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_lo_release(blob)" returnType="blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_lo_release(informix.blob)
	returns integer
	external name '(sq_lo_release)'
	language c           -- this is variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_lo_seek(integer,int8,integer,out int8)" returnType="integer,int8,integer,out int8" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_lo_seek(integer, int8, integer, out int8)
	returns integer
	external name '(sq_lo_seek)'
	language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_lo_stat(integer,out ifx_lo_stat)" returnType="integer,out ifx_lo_stat" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_lo_stat(integer, out informix.ifx_lo_stat)
	returns integer
	external name '(sq_lo_stat)'
	language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_lo_tell(integer,out int8)" returnType="integer,out int8" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_lo_tell(integer, out int8)
	returns integer
	external name '(sq_lo_tell)'
	language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_lo_to_file(blob,lvarchar,integer,out integer)" returnType="blob,lvarchar,integer,out integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_lo_to_file(informix.blob, informix.lvarchar, int, out int)
	returns informix.lvarchar
	external name '(sq_lo_to_file)'
	language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_lo_truncate(integer,int8)" returnType="integer,int8" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_lo_truncate(integer, int8)
	returns integer
	external name '(sq_lo_truncate)'
	language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_lo_unlock(integer,int8,integer,int8)" returnType="integer,int8,integer,int8" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_lo_unlock(integer, int8, integer, int8)
	returns integer
	external name '(sq_lo_unlock)'
	language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_load_internal(varchar,varchar)" returnType="varchar,varchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_load_internal(varchar(255), varchar(255))
        returns int
	external name '' language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_load_module(varchar,varchar)" returnType="varchar,varchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="spl"><![CDATA[create dba procedure informix.ifx_load_module (modulename varchar(255),
        languagename varchar(255)) returns int

     define retvalue int;
     let retvalue = reload_module(modulename, languagename);
     if retvalue = 0 then
         return 0;
     else
         raise exception -9720;
     end if;
end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_match_external(varchar,varchar)" returnType="varchar,varchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_match_external(varchar(255), varchar(255))
        returns int
	external name '' language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_new_external(varchar,varchar,varchar)" returnType="varchar,varchar,varchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_new_external(varchar(255), varchar(255),
        varchar(255))
        returns informix.lvarchar
	external name '' language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_node_id()" returnType="" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_node_id()
    returns integer as ifx_node_id
    with (not variant)
    external name '(ifx_grid_id)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_node_name()" returnType="" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_node_name()
    returns informix.lvarchar as ifx_node_name
    with (not variant)
    external name '(ifx_grid_name)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_param_ids(integer)" returnType="integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_param_ids(integer)
returning informix.lvarchar
external name '(spr_param_ids)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_param_types(integer)" returnType="integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_param_types(integer)
returning informix.lvarchar
external name '(spr_param_types)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_replace_module(varchar,varchar,varchar)" returnType="varchar,varchar,varchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="spl"><![CDATA[create dba procedure informix.ifx_replace_module (oldmodulename varchar(255),
        newmodulename varchar(255),
        languagename varchar(255)) returns int

     define retvalue int;
     let retvalue = ifx_invalid_module(oldmodulename,
                          languagename);

     if retvalue = 0 then
         let retvalue = ifx_update_extern( oldmodulename, newmodulename, languagename);
         update informix.sysprocedures
         set externalname = ifx_new_external(newmodulename, externalname,
                              languagename)
         where ifx_match_external(oldmodulename, externalname) = 1;
         let retvalue = ifx_load_internal(newmodulename, languagename);
     end if;

     if retvalue = 0 then
         return 0;
     else
         raise exception -9720;
     end if;

end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_replace_module(varchar,varchar,varchar,varchar)" returnType="varchar,varchar,varchar,varchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="spl"><![CDATA[create dba procedure informix.ifx_replace_module (oldmodulename varchar(255),
        newmodulename varchar(255),
        languagename varchar(255), module_ownername varchar(32)) returns int

     define retvalue int;
     let retvalue = ifx_invalid_module(oldmodulename,
                          languagename);

     if retvalue = 0 then
         let retvalue = ifx_update_extern( oldmodulename, newmodulename, languagename);
         update informix.sysprocedures
         set externalname = ifx_new_external(newmodulename, externalname,
                              languagename)
         where owner = module_ownername
             and ifx_match_external(oldmodulename, externalname) = 1;
         let retvalue = ifx_load_internal(newmodulename, languagename);
     end if;

     if retvalue = 0 then
         return 0;
     else
         raise exception -9720;
     end if;

end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_ret_ids(integer)" returnType="integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_ret_ids(integer)
returning informix.lvarchar
external name '(spr_ret_ids)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_ret_types(integer)" returnType="integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_ret_types(integer)
returning informix.lvarchar
external name '(spr_ret_types)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_set_erstate(integer)" returnType="integer" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_set_erstate( informix.integer)
    external name '(ifx_set_erstate1)'
    language C
    end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_set_erstate(lvarchar)" returnType="lvarchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba procedure informix.ifx_set_erstate( informix.lvarchar)
    external name '(ifx_set_erstate2)'
    language C
    end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_sha_settrace(integer,lvarchar)" returnType="integer,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[---Create function to enable trace.
create dba function informix.ifx_sha_settrace(integer, lvarchar)
	returns integer
	external name '(ifx_sha_settrace)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ifx_shard_delete(lvarchar,lvarchar,lvarchar)" returnType="lvarchar,lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.ifx_shard_delete(informix.lvarchar, informix.lvarchar,
	informix.lvarchar)
	returning integer
	external name '(ifx_shard_delete)'
	language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_trigger_action(integer,char)" returnType="integer,char" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="spl"><![CDATA[create dba procedure informix.ifx_trigger_action(trigid int, when CHAR(10))
	returns informix.lvarchar;
	define cleanwhen	char(10);
	define intwhen		int;

	let cleanwhen = trim (BOTH FROM when);
	if (cleanwhen = 'BEFORE' or cleanwhen = 'before') then
	    let intwhen = 1;
	elif (cleanwhen = 'ROW' or cleanwhen = 'row') then
	    let intwhen = 2;
	elif (cleanwhen = 'AFTER' or cleanwhen = 'after') then
	    let intwhen = 3;
	else
	    return NULL;
	end if;

	return (informix.trigger_action(trigid, intwhen));
end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_trigger_cols(integer)" returnType="integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="spl"><![CDATA[create dba procedure informix.ifx_trigger_cols(trigid int)
	returns informix.lvarchar
	return (informix.trigger_cols(trigid));
end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_unload_module(varchar,varchar)" returnType="varchar,varchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="spl"><![CDATA[create procedure informix.ifx_unload_module (modulename varchar(255),
        languagename varchar(255)) returns int

     define retvalue int;
     let retvalue = unloading_module(modulename, languagename);
     if retvalue = 0 then
         return 0;
     end if;
     if retvalue = -1 then
         raise exception -9721;
     else
         raise exception -9720;
     end if;
end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="ifx_update_extern(varchar,varchar,varchar)" returnType="varchar,varchar,varchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[---
---	end java UDRs
---


create dba function informix.ifx_update_extern(varchar(255), varchar(255),
        varchar(255) )
        returns  int
        external name '' language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="ikeyextractcolno(indexkeyarray,integer)" returnType="indexkeyarray,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- Used to create the sysindexes view definition
create dba function informix.ikeyextractcolno(informix.indexkeyarray, integer)
returning smallint
external name '(ikeyextractcolno)' language C
not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="indexkeyarray_out(indexkeyarray)" returnType="indexkeyarray" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- Let us create the output function for this. We do not need an input function
create dba function informix.indexkeyarray_out(informix.indexkeyarray)
returning informix.lvarchar
external name '(indexkeyarray_out)' language C
not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="indexkeyarray_out(indexkeyarray,integer)" returnType="indexkeyarray,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.indexkeyarray_out(informix.indexkeyarray, integer)
returning informix.lvarchar
external name '(indexkeyarraywithlen_out)' language C
not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="indexkeyarray_send(indexkeyarray)" returnType="indexkeyarray" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.indexkeyarray_send(informix.indexkeyarray)
returning informix.sendrecv
external name '(indexkeyarray_send)' language C
not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="indexkeyarray_send(indexkeyarray,integer)" returnType="indexkeyarray,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.indexkeyarray_send(informix.indexkeyarray, integer)
returning informix.sendrecv
external name '(indexkeyarraywithlen_send)' language C
not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="init_aggrelem(row,lvarchar)" returnType="row,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.init_aggrelem(informix.ROW, informix.lvarchar)
returns informix.pointer
external name '(init_aggrelem)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="init_aggrelemc(row,lvarchar)" returnType="row,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.init_aggrelemc(informix.ROW, informix.lvarchar)
returns  informix.pointer
external name '(init_aggrelemc)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="init_aggrschema(row,lvarchar)" returnType="row,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.init_aggrschema(informix.ROW, informix.lvarchar)
returns informix.pointer
external name '(init_aggrschema)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="init_aggrschemac(row,lvarchar)" returnType="row,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.init_aggrschemac(informix.ROW, informix.lvarchar)
returns  informix.pointer
external name '(init_aggrschemac)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="init_aggrxml(row,lvarchar)" returnType="row,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.init_aggrxml(informix.ROW, informix.lvarchar)
returns  informix.pointer
external name '(init_aggrxml)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="init_aggrxmlc(row,lvarchar)" returnType="row,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.init_aggrxmlc(informix.ROW, informix.lvarchar)
returns  informix.pointer
external name '(init_aggrxmlc)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="install_jar(varchar,varchar)" returnType="varchar,varchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="java"><![CDATA[---
---	Register builtin java UDRs for Krakatoa
---

create dba procedure sqlj.install_jar(varchar(255), varchar(255))
external name 'informix.jvp.dbapplet.impl.JarHandler.installJar(java.lang.String, java.lang.String)' language java end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="install_jar(varchar,varchar,integer)" returnType="varchar,varchar,integer" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="java"><![CDATA[create dba procedure sqlj.install_jar(varchar(255), varchar(255), int)
external name 'informix.jvp.dbapplet.impl.JarHandler.installJar(java.lang.String, java.lang.String, int)' language java end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="install_jar_deploy(varchar,varchar)" returnType="varchar,varchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="java"><![CDATA[create dba procedure sqlj.install_jar_deploy(varchar(255), varchar(255))
external name 'informix.jvp.dbapplet.impl.JarHandler.installJarDeploy(java.lang.String, java.lang.String)' language java end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="is_pattern_arg(varchar,char)" returnType="varchar,char" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="spl"><![CDATA[create procedure informix.is_pattern_arg(str1 varchar(255), options char(4000)) returning integer

return 1;
end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="iter_aggrelem(pointer,row)" returnType="pointer,row" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.iter_aggrelem(informix.pointer, informix.ROW)
returns informix.pointer
external name '(iter_aggrelem)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="iter_aggrelemc(pointer,row)" returnType="pointer,row" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.iter_aggrelemc(informix.pointer, informix.ROW)
returns  informix.pointer
external name '(iter_aggrelemc)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="iter_aggrschema(pointer,row)" returnType="pointer,row" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.iter_aggrschema(informix.pointer, informix.ROW)
returns informix.pointer
external name '(iter_aggrschema)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="iter_aggrschemac(pointer,row)" returnType="pointer,row" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.iter_aggrschemac(informix.pointer, informix.ROW)
returns  informix.pointer
external name '(iter_aggrschemac)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="iter_aggrxml(pointer,row)" returnType="pointer,row" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.iter_aggrxml(informix.pointer, informix.ROW)
returns  informix.pointer
external name '(iter_aggrxml)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="iter_aggrxmlc(pointer,row)" returnType="pointer,row" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.iter_aggrxmlc(informix.pointer, informix.ROW)
returns  informix.pointer
external name '(iter_aggrxmlc)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="javaclass(smallint,smallint,char)" returnType="smallint,smallint,char" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.JavaClass(
	s_id  smallint,
	type  smallint,
	mode   char(2))
returning lvarchar(35)
with (HANDLESNULLS)
external name '(get_java_classname)'
LANGUAGE C
END FUNCTION;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="json_export_bin(json)" returnType="json" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.json_export_bin(json) returns impexpbin
with (not variant, parallelizable)
external name '(json_export_bin)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="json_export_txt(json)" returnType="json" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.json_export_txt(json) returns impexp
with (not variant, parallelizable)
external name '(json_export_txt)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="json_import_bin(impexpbin)" returnType="impexpbin" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.json_import_bin(impexpbin) returns json
with (not variant, parallelizable)
external name '(json_import_bin)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="json_import_txt(impexp)" returnType="impexp" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.json_import_txt(impexp) returns json
with (not variant, parallelizable)
external name '(json_import_txt)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="json_in(lvarchar)" returnType="lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.json_in(lvarchar) returns json
with (not variant, parallelizable)
external name '(json_input)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="json_out(json)" returnType="json" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.json_out(json) returns lvarchar
with  (not variant, parallelizable)
external name '(json_out)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="json_recv(sendrecv)" returnType="sendrecv" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.json_recv(sendrecv) returns json
with  (not variant, parallelizable)
external name '(json_recv)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="json_send(json)" returnType="json" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.json_send(json) returns sendrecv
with (not variant, parallelizable)
external name '(json_send)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="json_to_bson(json)" returnType="json" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.json_to_bson(informix.json) returning informix.bson
        external name '(json_to_bson_output)'
        language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="jsonoutput(bson)" returnType="bson" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.jsonoutput(informix.bson) returning informix.json
external name '(json_output)'
language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="jvpcontrol(lvarchar)" returnType="lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="java"><![CDATA[create dba function informix.jvpcontrol(informix.lvarchar)
    returns informix.lvarchar with (iterator)
    external name
    'informix.jvp.dbapplet.impl.JVPControl.JVPControlUDR(java.lang.String)'
    language java end function;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="lessthan(longlvarchar,longlvarchar)" returnType="longlvarchar,longlvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.lessthan(informix.longlvarchar, informix.longlvarchar)
returns informix.boolean
external name '(llvc_lt)' language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="lessthanorequal(longlvarchar,longlvarchar)" returnType="longlvarchar,longlvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.lessthanorequal(informix.longlvarchar, informix.longlvarchar)
returns informix.boolean
external name '(llvc_le)' language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="llvc_export_bin(longlvarchar)" returnType="longlvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.llvc_export_bin(longlvarchar) returns impexpbin
with (not variant, parallelizable)
external name '(llvc_export_bin)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="llvc_export_txt(longlvarchar)" returnType="longlvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.llvc_export_txt(longlvarchar) returns impexp
with (not variant, parallelizable)
external name '(llvc_export_txt)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="llvc_import_bin(impexpbin)" returnType="impexpbin" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.llvc_import_bin(impexpbin) returns longlvarchar
with (not variant, parallelizable)
external name '(llvc_import_bin)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="llvc_import_txt(impexp)" returnType="impexp" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.llvc_import_txt(impexp) returns longlvarchar
with (not variant, parallelizable)
external name '(llvc_import_txt)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="llvc_in(lvarchar)" returnType="lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.llvc_in(lvarchar) returns longlvarchar
with (not variant, parallelizable)
external name '(llvc_input)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="llvc_out(longlvarchar)" returnType="longlvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.llvc_out(longlvarchar) returns lvarchar
with  (not variant, parallelizable)
external name '(llvc_output)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="llvc_recv(sendrecv)" returnType="sendrecv" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.llvc_recv(sendrecv) returns longlvarchar
with  (not variant, parallelizable)
external name '(llvc_recv)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="llvc_send(longlvarchar)" returnType="longlvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.llvc_send(longlvarchar) returns sendrecv
with (not variant, parallelizable)
external name '(llvc_send)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="locopy(blob)" returnType="blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.locopy(informix.blob)
	returns informix.blob
	external name '(blob_copy)'
	language c variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="locopy(blob,char,char)" returnType="blob,char,char" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.locopy(informix.blob, char(128), char(128))
	returns informix.blob
        with (handlesnulls)
	external name '(blob_copy_colspec)'
	language c variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="locopy(clob)" returnType="clob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.locopy(informix.clob)
	returns informix.clob
	external name '(blob_copy)'
	language c variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="locopy(clob,char,char)" returnType="clob,char,char" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.locopy(informix.clob, char(128), char(128))
	returns informix.clob
        with (handlesnulls)
	external name '(blob_copy_colspec)'
	language c variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="locopy_blobpre1170(blob,char,char)" returnType="blob,char,char" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.locopy(informix.blob, char(18), char(18))
	returns informix.blob
	external name '(blob_copy_colspec)'
	language c variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="locopy_clobpre1170(clob,char,char)" returnType="clob,char,char" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.locopy(informix.clob, char(18), char(18))
	returns informix.clob
	external name '(blob_copy_colspec)'
	language c variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="lohandles(blob)" returnType="blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.lohandles(informix.blob)
	returns informix.lolist
	external name '(blob_handles)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="lohandles(clob)" returnType="clob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.lohandles(informix.clob)
	returns informix.lvarchar
	external name '(blob_handles)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="lolist_in(lvarchar)" returnType="lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- lolist function and cast definitions
create dba function informix.lolist_in(informix.lvarchar)
	returns informix.lolist
        external name '(lolist_in)'
        language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="lolist_out(lolist)" returnType="lolist" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.lolist_out(informix.lolist)
	returns informix.lvarchar
        external name '(lolist_out)'
        language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="lolist_recv(sendrecv)" returnType="sendrecv" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.lolist_recv(informix.sendrecv)
	returns informix.lolist
        external name '(lolist_recv)'
        language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="lolist_send(lolist)" returnType="lolist" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.lolist_send(informix.lolist)
	returns informix.sendrecv
        external name '(lolist_send)'
        language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="lotofile(blob,lvarchar,char)" returnType="blob,lvarchar,char" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.lotofile(informix.blob, informix.lvarchar, char(6)) returns informix.lvarchar
	external name '(blob_to_file)'
	language c variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="lotofile(clob,lvarchar,char)" returnType="clob,lvarchar,char" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.lotofile(clob, informix.lvarchar, char(6)) returns informix.lvarchar
	external name '(blob_to_file)'
	language c variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="metadata()" returnType="" securityType="Restricted" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="spl"><![CDATA[create procedure SYSIBM.METADATA() returning integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, lvarchar(4096), varchar(100), varchar(100),varchar(100), varchar(100), varchar(25), varchar(25), integer, integer, integer, varchar(255), integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, varchar(50), varchar(50), varchar(50), integer, varchar(50), integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, varchar(50), integer, integer, integer, integer, varchar(100), varchar(100), varchar(100), varchar(100), varchar(100), varchar(100), varchar(100), varchar(100), varchar(100), varchar(100), varchar(100), integer, integer, integer

define r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14 integer;
define r15 lvarchar(4096);
define r16, r17, r18, r19 varchar(100);
define r20, r21 varchar(25);
define r22, r23, r24 integer;

define r25 varchar(255);
define r26, r27, r28, r29, r30, r31, r32, r33, r34, r35, r36, r37, r38, r39, r40, r41 integer;
define r42, r43, r44, r46 varchar(50);
define r45 integer;
define r47, r48, r49, r50, r51, r52, r53, r54, r55, r56, r57, r58, r59, r60, r61 integer;
define r62, r63, r64, r65, r66, r67, r68, r69, r70, r71, r72, r73, r74, r75, r76, r77, r78, r79, r80, r81, r82, r83, r84, r85, r86, r87, r88, r89, r90, r92, r93, r94, r95 integer;
define r91 varchar(50);
define r96, r97, r98, r99, r100, r101, r102, r103, r104, r105, r106  varchar(100);
define r107, r108, r109, r110, r111, r112 integer;

select o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19, o20, o21, o22, o23, o24, o25, o26, o27, o28, o29, o30, o31, o32, o33, o34, o35, o36, o37, o38, o39, o40, o41, o42, o43, o44, o45, o46, o47, o48, o49, o50, o51, o52, o53, o54, o55, o56, o57, o58, o59, o60, o61 into r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31, r32, r33, r34, r35, r36, r37, r38, r39, r40, r41, r42, r43, r44, r45, r46, r47, r48, r49, r50, r51, r52, r53, r54, r55, r56, r57, r58, r59, r60, r61 from informix.systables where informix.metadata_1(o1 # int, o2 # int, o3 # int, o4 # int, o5 # int, o6 # int, o7 # int, o8 # int, o9 # int, o10 # int, o11 # int, o12 # int, o13 # int, o14 # int, o15 # lvarchar(4096), o16 # varchar(100), o17 # varchar(100), o18 # varchar(100), o19 # varchar(100), o20 # varchar(25), o21 # varchar(25), o22 # int, o23 # int, o24 # int, o25 # varchar(255), o26 # int, o27 # int, o28 # int, o29 # int, o30 # int, o31 # int, o32 # int, o33 # int, o34 # int, o35 # int, o36 # int, o37 # int, o38 # int, o39 # int, o40 # int, o41 # int, o42 # varchar(50), o43 # varchar(50), o44 # varchar(50), o45 # int, o46 # varchar(50), o47 # int, o48 # int, o49 # int, o50 # int, o51 # int, o52 # int, o53 # int, o54 # int, o55 # int, o56 # int, o57 # int, o58 # int, o59 # int, o60 # int, o61 # int) = 1 and tabid = 1;

select o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19, o20, o21, o22, o23, o24, o25, o26, o27, o28, o29, o30, o31, o32, o33, o34, o35, o36, o37, o38, o39, o40, o41, o42, o43, o44, o45, o46, o47, o48, o49, o50, o51 into r62, r63, r64, r65, r66, r67, r68, r69, r70, r71, r72, r73, r74, r75, r76, r77, r78, r79, r80, r81, r82, r83, r84, r85, r86, r87, r88, r89, r90, r91, r92, r93, r94, r95, r96, r97, r98, r99, r100, r101, r102, r103, r104, r105, r106, r107, r108, r109, r110, r111, r112 from informix.systables where informix.metadata_2(o1 # int, o2 # int, o3 # int, o4 # int, o5 # int, o6 # int, o7 # int, o8 # int, o9 # int, o10 # int, o11 # int, o12 # int, o13 # int, o14 # int, o15 # int, o16 # int, o17 # int, o18 # int, o19 # int, o20 # int, o21 # int, o22 # int, o23 # int, o24 # int, o25 # int, o26 # int, o27 # int, o28 # int, o29 # int, o30 # varchar(50), o31 # int, o32 # int, o33 # int, o34 # int, o35 # varchar(100), o36 # varchar(100), o37 # varchar(100), o38 # varchar(100), o39 # varchar(100), o40 # varchar(100), o41 # varchar(100), o42 # varchar(100), o43 # varchar(100), o44 # varchar(100), o45 # varchar(100), o46 # int, o47 # int, o48 # int, o49 # int, o50 # int, o51 # int) = 1 and tabid = 1;

return r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31, r32, r33, r34, r35, r36, r37, r38, r39, r40, r41, r42, r43, r44, r45, r46, r47, r48, r49, r50, r51, r52, r53, r54, r55, r56, r57, r58, r59, r60, r61, r62, r63, r64, r65, r66, r67, r68, r69, r70, r71, r72, r73, r74, r75, r76, r77, r78, r79, r80, r81, r82, r83, r84, r85, r86, r87, r88, r89, r90, r91, r92, r93, r94, r95, r96, r97, r98, r99, r100, r101, r102, r103, r104, r105, r106, r107, r108, r109 with resume;

end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="metadata_1(out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out lvarchar,out varchar,out varchar,out varchar,out varchar,out varchar,out varchar,out integer,out integer,out integer,out varchar,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out varchar,out varchar,out varchar,out integer,out varchar,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer)" returnType="out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out lvarchar,out varchar,out varchar,out varchar,out varchar,out varchar,out varchar,out integer,out integer,out integer,out varchar,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out varchar,out varchar,out varchar,out integer,out varchar,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.metadata_1(
    out allProceduresAreCallable    integer,  /* 1 */
    out allTablesAreSelectable      integer,
    out nullsAreSortedHigh          integer,
    out nullsAreSortedLow           integer,
    out nullsAreSortedAtStart       integer,
    out nullsAreSortedAtEnd         integer,
    out usesLocalFiles              integer,
    out usesLocalFilePerTable       integer,
    out storesUpperCaseIdentifiers  integer,
    out storesLowerCaseIdentifiers  integer,
    out storesMixedCaseIdentifiers  integer,
    out storesUpperCaseQuotedIdentifiers  integer,
    out storesLowerCaseQuotedIdentifiers  integer,
    out storesMixedCaseQuotedIdentifiers  integer,  /* 14 */
    out getSQLKeywords              lvarchar(4096), /* 15 */
    out getNumericFunctions         varchar(150),
    out getStringFunctions          varchar(150),
    out getSystemFunctions          varchar(150),
    out getTimeDateFunctions        varchar(150),
    out getSearchStringEscape       varchar(25),     /* 20 */
    out getExtraNameCharacters      varchar(25),     /* 21 */
    out supportsAlterTableWithAddColumn    integer,
    out supportsAlterTableWithDropColumn   integer,
    out supportsConvert                    integer,
    out supportsConvertType                varchar(255),  /* 25 */
    out supportsDifferentTableCorrelationNames   integer, /* 26 */
    out supportsExpressionsInOrderBy          integer,
    out supportsOrderByUnrelated              integer,
    out supportsGroupBy                       integer,
    out supportsGroupByUnrelated              integer,
    out supportsGroupByBeyondSelect           integer,
    out supportsMultipleResultSets            integer,
    out supportsMultipleTransactions          integer,
    out supportsCoreSQLGrammar                integer,
    out supportsExtendedSQLGrammar            integer,
    out supportsANSI92IntermediateSQL         integer,
    out supportsANSI92FullSQL                 integer,
    out supportsIntegrityEnhancementFacility  integer,
    out supportsOuterJoins                    integer,
    out supportsFullOuterJoins                integer,
    out supportsLimitedOuterJoins             integer,   /* 41 */
    out getSchemaTerm                         varchar(50), /* 42 */
    out getProcedureTerm                      varchar(50),
    out getCatalogTerm                        varchar(50),  /* 44 */
    out isCatalogAtStart                      integer,  /* 45 */
    out getCatalogSeparator                   varchar(50),  /* 46 */
    out supportsSchemasInDataManipulation     integer,  /* 47 */
    out supportsSchemasInProcedureCalls       integer,
    out supportsSchemasInTableDefinitions     integer,
    out supportsSchemasInIndexDefinitions     integer,
    out supportsSchemasInPrivilegeDefinitions integer,
    out supportsCatalogsInDataManipulation    integer,
    out supportsCatalogsInProcedureCalls      integer,
    out supportsCatalogsInTableDefinitions    integer,
    out supportsCatalogsInIndexDefinitions    integer,
    out supportsCatalogsInPrivilegeDefinitions    integer,
    out supportsPositionedDelete              integer,
    out supportsPositionedUpdate              integer,
    out supportsSelectForUpdate               integer,
    out supportsStoredProcedures              integer,
    out supportsSubqueriesInComparisons       integer)
returning integer
with (handlesnulls)
external name '(metadata_1)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="metadata_2(out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out varchar,out integer,out integer,out integer,out integer,out varchar,out varchar,out varchar,out varchar,out varchar,out varchar,out varchar,out varchar,out varchar,out varchar,out varchar,out integer,out integer,out integer,out integer,out integer,out integer)" returnType="out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out integer,out varchar,out integer,out integer,out integer,out integer,out varchar,out varchar,out varchar,out varchar,out varchar,out varchar,out varchar,out varchar,out varchar,out varchar,out varchar,out integer,out integer,out integer,out integer,out integer,out integer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.metadata_2(
    out supportsUnion                         integer,  /* 62 */
    out supportsUnionAll                      integer,
    out supportsOpenCursorsAcrossCommit       integer,
    out supportsOpenCursorsAcrossRollback     integer,
    out supportsOpenStatementsAcrossCommit    integer,
    out supportsOpenStatementsAcrossRollback  integer,
    out getMaxBinaryLiteralLength             integer,
    out getMaxCharLiteralLength               integer,
    out getMaxColumnNameLength                integer,   /* 70 */
    out getMaxColumnsInGroupBy                integer,   /* 71 */
    out getMaxColumnsInIndex                  integer,
    out getMaxColumnsInOrderBy                integer,
    out getMaxColumnsInSelect                 integer,
    out getMaxColumnsInTable                  integer,
    out getMaxConnections                     integer,
    out getMaxCursorNameLength                integer,
    out getMaxIndexLength                     integer,
    out getMaxSchemaNameLength                integer,
    out getMaxProcedureNameLength             integer,  /* 80 */
    out getMaxCatalogNameLength               integer,  /* 81 */
    out getMaxRowSize                         integer,
    out doesMaxRowSizeIncludeBlobs            integer,
    out getMaxStatementLength                 integer,
    out getMaxStatements                      integer,
    out getMaxTableNameLength                 integer,
    out getMaxTablesInSelect                  integer,
    out getMaxUserNameLength                  integer,
    out getDefaultTransactionIsolation        integer,
    out supportsTransactions                  integer,   /* 90 */
    out supportsTransactionIsolationLevel     varchar(50),  /* 91 */
    out supportsDataDefinitionAndDataManipulationTransactions   integer,
    out supportsDataManipulationTransactionsOnly     integer,
    out dataDefinitionCausesTransactionCommit        integer,
    out dataDefinitionIgnoredInTransactions          integer,
    out supportsResultSetType                 varchar(50),   /* 96 */
    out supportsResultSetConcurrency          varchar(50),
    out ownUpdatesAreVisible                  varchar(100),
    out ownDeletesAreVisible                  varchar(100),
    out ownInsertsAreVisible                  varchar(100),
    out othersUpdatesAreVisible               varchar(100),
    out othersDeletesAreVisible               varchar(100),
    out othersInsertsAreVisible               varchar(100),
    out updatesAreDetected                    varchar(100),
    out deletesAreDetected                    varchar(100),
    out insertsAreDetected                    varchar(100),  /* 106 */
    out supportsBatchUpdates                  integer,  /* 107 */
    out supportsSavepoints                    integer,
    out supportsGetGeneratedKeys              integer,
    out isANSI                                integer,
    out isLogged                              integer,
    out isBufferedLog                         integer)
returning integer
with ( handlesnulls )
external name '(metadata_2)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="mi_cast_datum(clientbinval,integer,integer,integer,integer)" returnType="clientbinval,integer,integer,integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.mi_cast_datum(informix.clientbinval,
	  int, int, int, int)
	returns informix.clientbinval
	external name '(mife_cast_datum)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="mi_cast_datum(clientbinval,lvarchar,lvarchar)" returnType="clientbinval,lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.mi_cast_datum(informix.clientbinval,
	  informix.lvarchar, informix.lvarchar)
	returns informix.clientbinval
	external name '(mife_cast_datum_by_name)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="mi_cast_datum(sendrecv,integer,integer,integer,integer)" returnType="sendrecv,integer,integer,integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.mi_cast_datum(informix.sendrecv,
	  int, int, int, int)
	returns informix.sendrecv
	external name '(mife_cast_datum)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="mi_cast_datum(sendrecv,lvarchar,lvarchar)" returnType="sendrecv,lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.mi_cast_datum(informix.sendrecv,
	  informix.lvarchar, informix.lvarchar)
	returns informix.sendrecv
	external name '(mife_cast_datum_by_name)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="mi_get_typedesc(integer,integer)" returnType="integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.mi_get_typedesc(int,int)
        returns informix.lvarchar
        external name '(mife_type_typedesc)'
        language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="mi_get_typedesc(lvarchar)" returnType="lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.mi_get_typedesc(informix.lvarchar)
        returns informix.lvarchar
        external name '(mife_describe_typestring)'
        language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="notequal(json,json)" returnType="json,json" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.notequal(informix.json, informix.json)
returns informix.boolean
external name '(json_ne)' language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="notequal(longlvarchar,longlvarchar)" returnType="longlvarchar,longlvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.notequal(informix.longlvarchar, informix.longlvarchar)
returns informix.boolean
external name '(llvc_ne)' language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="push2_combine(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.push2_combine(informix.lvarchar, informix.lvarchar)
returns informix.lvarchar with (handlesnulls, not variant)
external name '(bson_push2_combine)' language c ;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="push2_final(lvarchar)" returnType="lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.push2_final(informix.lvarchar)
returns informix.bson with (handlesnulls, not variant)
external name '(bson_push2_final)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="push2_init(bson)" returnType="bson" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.push2_init(informix.bson)
returns informix.lvarchar with (handlesnulls, not variant)
external name '(bson_push2_init)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="push2_iter(lvarchar,bson)" returnType="lvarchar,bson" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.push2_iter(informix.lvarchar, informix.bson)
returns informix.lvarchar with (handlesnulls, not variant)
external name '(bson_push2_iter)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="push_combine(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.push_combine(informix.lvarchar, informix.lvarchar)
returns informix.lvarchar with (handlesnulls, not variant)
external name '(bson_push_combine)' language c ;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="push_final(lvarchar)" returnType="lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.push_final(informix.lvarchar)
returns informix.bson with (handlesnulls, not variant)
external name '(bson_push_final)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="push_init(bson)" returnType="bson" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.push_init(informix.bson)
returns informix.lvarchar with (handlesnulls, not variant)
external name '(bson_push_init)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="push_iter(lvarchar,bson)" returnType="lvarchar,bson" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.push_iter(informix.lvarchar, informix.bson)
returns informix.lvarchar with (handlesnulls, not variant)
external name '(bson_push_iter)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rci_beginscan(pointer)" returnType="pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.rci_beginscan(informix.pointer)
    returns int
    external name '(rci_beginscan)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rci_close(pointer)" returnType="pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.rci_close(informix.pointer)
    returns int
    external name '(rci_close)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rci_create(pointer)" returnType="pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.rci_create(informix.pointer)
    returns int
    external name '(rci_create)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rci_delete(pointer,pointer,pointer)" returnType="pointer,pointer,pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.rci_delete(informix.pointer, informix.pointer, informix.pointer)
    returns int
    external name '(shash_stub3)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rci_drop(pointer)" returnType="pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.rci_drop(informix.pointer)
    returns int
    external name '(rci_drop)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rci_endscan(pointer)" returnType="pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.rci_endscan(informix.pointer)
    returns int
    external name '(rci_endscan)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rci_getnext(pointer,pointer,pointer)" returnType="pointer,pointer,pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.rci_getnext(informix.pointer, informix.pointer, informix.pointer)
    returns int
    external name '(rci_getnext)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rci_insert(pointer,pointer,pointer)" returnType="pointer,pointer,pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.rci_insert(informix.pointer, informix.pointer, informix.pointer)
    returns int
    external name '(shash_stub3)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rci_open(pointer)" returnType="pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.rci_open(informix.pointer)
    returns int
    external name '(rci_open)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rci_rescan(pointer)" returnType="pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.rci_rescan(informix.pointer)
    returns int
    external name '(rci_rescan)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rci_scancost(pointer)" returnType="pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.rci_scancost(informix.pointer)
    returns float
    external name '(rci_scancost)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rci_update(pointer,pointer,pointer,pointer,pointer)" returnType="pointer,pointer,pointer,pointer,pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.rci_update(informix.pointer, informix.pointer, informix.pointer, informix.pointer, informix.pointer)
    returns int
    external name '(shash_stub5)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="recv_spec(sendrecv)" returnType="sendrecv" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.recv_spec(informix.sendrecv)
	returns informix.ifx_lo_spec
	external name '(recv_ifx_lo_spec)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="recv_stat(sendrecv)" returnType="sendrecv" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.recv_stat(informix.sendrecv)
	returns informix.ifx_lo_stat
	external name '(recv_ifx_lo_stat)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="registerjudtfuncs(varchar)" returnType="varchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="java"><![CDATA[---
---	Register builtin java UDRs for Krakatoa
---

create dba procedure sqlj.registerJUDTfuncs(varchar(255)) external name
 'informix.jvp.dbapplet.impl.JarHandler.registerJUDTfuncs(java.lang.String)'
 language java end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="reload_module(varchar,varchar)" returnType="varchar,varchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.reload_module(varchar(255), varchar(255))
        returns int
        external name '' language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="remove_jar(varchar)" returnType="varchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="java"><![CDATA[create dba procedure sqlj.remove_jar(varchar(255))
external name 'informix.jvp.dbapplet.impl.JarHandler.removeJar(java.lang.String) ' language java end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="remove_jar(varchar,integer)" returnType="varchar,integer" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="java"><![CDATA[create dba procedure sqlj.remove_jar(varchar(255), int)
external name 'informix.jvp.dbapplet.impl.JarHandler.removeJar(java.lang.String, int) ' language java end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="remove_jar_undeploy(varchar)" returnType="varchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="java"><![CDATA[create dba procedure sqlj.remove_jar_undeploy(varchar(255))
external name 'informix.jvp.dbapplet.impl.JarHandler.removeJarUndeploy(java.lang.String)' language java end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="replace_jar(varchar,varchar)" returnType="varchar,varchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="java"><![CDATA[create dba procedure sqlj.replace_jar(varchar(255), varchar(255))
external name 'informix.jvp.dbapplet.impl.JarHandler.replaceJar(java.lang.String, java.lang.String)' language java end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_abort(integer)" returnType="integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rlt_abort(int)
    returns int
    external name '(rlt_abort)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_beginscan(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rlt_beginscan(pointer)
    returns int
    external name '(rlt_beginscan)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_check(pointer,integer)" returnType="pointer,integer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[---Define rtree support function for oncheck
create function informix.rlt_check(pointer, integer)
	returns integer
	external name '(rlt_check)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_close(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rlt_close(pointer)
    returns int
    external name '(rlt_close)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_commit(integer)" returnType="integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rlt_commit(int)
    returns int
    external name '(rlt_commit)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_convert(integer)" returnType="integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- Define conversion and reversion functions for rtree index partitions
create dba function informix.rlt_convert(int)
    returns int
    external name '(rlt_convert)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_cost(pointer,pointer)" returnType="pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rlt_cost(pointer, pointer)
    returns real
    external name '(rlt_cost)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_create(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- Define rtree access method:
create dba function informix.rlt_create(pointer)
    returns int
    external name '(rlt_create)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_delete(pointer,pointer,pointer)" returnType="pointer,pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rlt_delete(pointer, pointer, pointer)
    returns int
    external name '(rlt_delete)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_drop(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rlt_drop(pointer)
    returns int
    external name '(rlt_drop)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_endscan(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rlt_endscan(pointer)
    returns int
    external name '(rlt_endscan)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_getnext(pointer,pointer,pointer)" returnType="pointer,pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rlt_getnext(pointer, pointer, pointer)
    returns int
    external name '(rlt_getnext)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_insert(pointer,pointer,pointer)" returnType="pointer,pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rlt_insert(pointer, pointer, pointer)
    returns int
    external name '(rlt_insert)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_open(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rlt_open(pointer)
    returns int
    external name '(rlt_open)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_redo(pointer,pointer,integer,integer)" returnType="pointer,pointer,integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- Define recovery related functions for the rtree access method:
create dba function informix.rlt_redo(pointer, pointer, int, int)
    returns int
    external name '(rlt_redo)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_rescan(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rlt_rescan(pointer)
    returns int
    external name '(rlt_rescan)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_revert(integer)" returnType="integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rlt_revert(int)
    returns int
    external name '(rlt_revert)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_stat(pointer,pointer)" returnType="pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- Define optimizer related functions for rtree access method
create dba function informix.rlt_stat(pointer, pointer)
    returns int
    external name '(rlt_stat)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_tracefile_set(lvarchar)" returnType="lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rlt_tracefile_set(informix.lvarchar)
	returns integer
	external name '(rlt_tracefile_set)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_tracelevel_set(integer)" returnType="integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[---Rtree tracing support
create dba function informix.rlt_tracelevel_set(integer)
	returns integer
	external name '(rlt_tracelevel_set)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_undo(pointer,pointer,integer,integer)" returnType="pointer,pointer,integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rlt_undo(pointer, pointer, int, int)
    returns int
    external name '(rlt_undo)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rlt_update(pointer,pointer,pointer,pointer,pointer)" returnType="pointer,pointer,pointer,pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rlt_update(pointer, pointer, pointer,
				    pointer, pointer)
    returns int
    external name '(rlt_update)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="rowcast(row)" returnType="row" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rowcast(row) returns row
        external name '(rowcast)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="rowexport(row)" returnType="row" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- Add rowimport/rowexport functions and casts
create dba function informix.rowexport(row) returns informix.impexp
        external name '(rowexport)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="rowimport(impexp)" returnType="impexp" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rowimport(informix.impexp) returns row
        external name '(rowimport)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="rowinput(lvarchar)" returnType="lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rowinput(informix.lvarchar) returns row
        external name '(rowinput)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="rowoutput(row)" returnType="row" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- Row Functions
create dba function informix.rowoutput(row) returns informix.lvarchar
        external name '(rowoutput)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="rowrecv(sendrecv)" returnType="sendrecv" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rowrecv(informix.sendrecv) returns row
        external name '(rowrecv)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="rowsend(row)" returnType="row" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rowsend(row) returns informix.sendrecv
        external name '(rowsend)' language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="rtn_param_out(rtnparamtypes)" returnType="rtnparamtypes" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- Let us create the output function for this. We do not need an input function
create dba function informix.rtn_param_out(informix.rtnparamtypes)
returning informix.lvarchar specific paramtypes_out
external name '(rtn_param_out)' language C
not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="rtnparamtypes_send(rtnparamtypes)" returnType="rtnparamtypes" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.rtnparamtypes_send(informix.rtnparamtypes)
returning informix.sendrecv
external name '(rtnparamtypes_send)' language C
not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="rtreerootbb(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[---Rtree root Bounding Box function
create dba function informix.rtreeRootBB(informix.lvarchar, informix.lvarchar)
	returns informix.lvarchar
        with (variant)
	external name '(rlt_root_bbox_info)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_auto_increment(smallint)" returnType="smallint" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.schema_auto_increment(coltype smallint)
returning smallint
external name '(schema_auto_increment)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_bufflen(smallint,smallint)" returnType="smallint,smallint" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.schema_bufflen(coltype smallint, collength smallint)
returning int
external name '(schema_bufflen)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_case_sensitive(smallint,integer)" returnType="smallint,integer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.schema_case_sensitive(coltype smallint, xtype integer)
returning smallint
external name '(schema_case_sensitive)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_charlen(smallint,integer,smallint)" returnType="smallint,integer,smallint" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.schema_charlen(coltype smallint, xtype integer, collength smallint)
returning int
external name '(schema_charlen)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_coltypename(smallint,integer)" returnType="smallint,integer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.schema_coltypename(coltype smallint, xtype integer)
returning char(18)
external name '(schema_coltypename)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_datetype(smallint,smallint)" returnType="smallint,smallint" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.schema_datetype (coltype smallint, collength smallint)
returning integer
external name '(schema_datetype)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_db2ids(smallint)" returnType="smallint" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.schema_db2ids(smallint) returning smallint
external name '(schema_db2ids)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_funccol_type(integer)" returnType="integer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.schema_funccol_type(proc_col_type integer)
returning integer
external name '(schema_funccol_type)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_ids2db2(smallint,smallint)" returnType="smallint,smallint" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- map ids datatypes to db2 types
create function informix.schema_ids2db2(smallint, smallint)
returning smallint
external name '(schema_ids2db2)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_isautoincr(smallint)" returnType="smallint" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.schema_isautoincr(coltype smallint)
returning char(3)
external name '(schema_isautoincr)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_isnullable(smallint)" returnType="smallint" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.schema_isnullable(coltype smallint)
returning integer
external name '(schema_isnullable)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_keywords(smallint,integer)" returnType="smallint,integer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.schema_keywords(coltype smallint, xtype integer)
returning varchar(128)
external name '(schema_keywords)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_nullable(smallint)" returnType="smallint" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.schema_nullable(coltype smallint)
returning char(3)
external name '(schema_nullable)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_numprecradix(smallint)" returnType="smallint" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.schema_numprecradix( coltype smallint)
returning int
external name '(schema_numprecradix)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_numscale(smallint,smallint)" returnType="smallint,smallint" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.schema_numscale(coltype smallint, collength smallint)
returning int
external name '(schema_numscale)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_precision(smallint,integer,smallint)" returnType="smallint,integer,smallint" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.schema_precision(coltype smallint, xtype integer, collength smallint)
returning int
external name '(schema_precision)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_searchable(smallint)" returnType="smallint" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.schema_searchable(coltype smallint)
returning smallint
external name '(schema_searchable)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="schema_unsigned_attribute(smallint)" returnType="smallint" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.schema_unsigned_attribute(coltype smallint)
returning smallint
external name '(schema_unsigned_attribute)'
LANGUAGE C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="seclabel_by_comp(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.SECLABEL_BY_COMP(informix.lvarchar,
    informix.lvarchar)
    returns informix.IDSSECURITYLABEL
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(ifx_seclabel_by_comp)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="seclabel_by_name(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.SECLABEL_BY_NAME(informix.lvarchar,
    informix.lvarchar)
    returns informix.IDSSECURITYLABEL
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(ifx_seclabel_by_name)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="seclabel_to_char(lvarchar,idssecuritylabel)" returnType="lvarchar,idssecuritylabel" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.SECLABEL_TO_CHAR(informix.lvarchar,
    informix.IDSSECURITYLABEL)
    returns informix.lvarchar
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(ifx_seclabel_to_char)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="seclabelinput(lvarchar)" returnType="lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.SeclabelInput(informix.lvarchar)
    returns informix.IDSSECURITYLABEL
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(seclabel_in)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="seclabeloutput(idssecuritylabel)" returnType="idssecuritylabel" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.SeclabelOutput(informix.IDSSECURITYLABEL)
    returns informix.lvarchar
    with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE)
    external name '(seclabel_out)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="send(ifx_lo_spec)" returnType="ifx_lo_spec" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.send(informix.ifx_lo_spec)
	returns informix.sendrecv
	external name '(send_ifx_lo_spec)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="send(ifx_lo_stat)" returnType="ifx_lo_stat" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.send(informix.ifx_lo_stat)
	returns informix.sendrecv
	external name '(send_ifx_lo_stat)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="send(stat)" returnType="stat" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.send(informix.stat)
       returns informix.sendrecv
       external name '(stat_send)'
       language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="setudtextname(varchar,varchar)" returnType="varchar,varchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="java"><![CDATA[create dba procedure sqlj.setUDTExtName(varchar(255), varchar(255))
external name 'informix.jvp.dbapplet.impl.JarHandler.setUDTExternalName(java.lang.String, java.lang.String)' language java end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sha_beginscan(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.sha_beginscan(informix.pointer)
	returns int
	external name '(sha_beginscan)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sha_close(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.sha_close(informix.pointer)
	returns int
	external name '(sha_close)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sha_create(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[--			MORE IMPORTANT: MUST READ

-- DO NOT ADD ANYTHING IN THIS FILE. ADDING STUFF IN THIS FILE MAY CAUSE
-- FAILURE IN CONVERSION/REVERSION PROCESS. USE boot920a.sql.

---Define the hash access method.
---Do not grant execute to public for these functions as
---they are special-cased within the engine with the exception
---of ifx_sha_settrace().

create dba function informix.sha_create(informix.pointer)
	returns int
	external name '(sha_create)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sha_delete(pointer,integer)" returnType="pointer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.sha_delete(informix.pointer, integer)
	returns int
	external name '(sha_delete)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sha_getbyid(pointer,pointer,integer)" returnType="pointer,pointer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.sha_getbyid(informix.pointer,
	    informix.pointer, integer)
	returns int
	external name '(sha_getbyid)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sha_getnext(pointer,pointer,pointer)" returnType="pointer,pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.sha_getnext(informix.pointer,
	    informix.pointer, informix.pointer)
	returns int
	external name '(sha_getnext)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sha_insert(pointer,pointer,pointer)" returnType="pointer,pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.sha_insert(informix.pointer,
	    informix.pointer, informix.pointer)
	returns int
	external name '(sha_insert)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sha_open(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.sha_open(informix.pointer)
	returns int
	external name '(sha_open)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sha_rescan(pointer)" returnType="pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.sha_rescan(informix.pointer)
	returns int
	external name '(sha_rescan)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sha_scancost(pointer,pointer)" returnType="pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.sha_scancost(informix.pointer,
	    informix.pointer)
	returns float
	external name '(sha_scancost)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sha_update(pointer,integer,pointer,pointer,pointer)" returnType="pointer,integer,pointer,pointer,pointer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.sha_update(informix.pointer,
	    integer, informix.pointer, informix.pointer,
	    informix.pointer)
	returns int
	external name '(sha_update)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="shash_beginscan(pointer)" returnType="pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.shash_beginscan(informix.pointer)
    returns int
    external name '(shash_beginscan)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="shash_close(pointer)" returnType="pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.shash_close(informix.pointer)
    returns int
    external name '(shash_stub1)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="shash_create(pointer)" returnType="pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.shash_create(informix.pointer)
    returns int
    external name '(shash_create)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="shash_delete(pointer,pointer,pointer)" returnType="pointer,pointer,pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.shash_delete(informix.pointer, informix.pointer, informix.pointer)
    returns int
    external name '(shash_stub3)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="shash_drop(pointer)" returnType="pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.shash_drop(informix.pointer)
    returns int
    external name '(shash_stub1)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="shash_endscan(pointer)" returnType="pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.shash_endscan(informix.pointer)
    returns int
    external name '(shash_endscan)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="shash_getnext(pointer,pointer,pointer)" returnType="pointer,pointer,pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.shash_getnext(informix.pointer, informix.pointer, informix.pointer)
    returns int
    external name '(shash_getnext)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="shash_insert(pointer,pointer,pointer)" returnType="pointer,pointer,pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.shash_insert(informix.pointer, informix.pointer, informix.pointer)
    returns int
    external name '(shash_stub3)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="shash_open(pointer)" returnType="pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.shash_open(informix.pointer)
    returns int
    external name '(shash_stub1)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="shash_rescan(pointer)" returnType="pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.shash_rescan(informix.pointer)
    returns int
    external name '(shash_rescan)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="shash_scancost(pointer)" returnType="pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.shash_scancost(informix.pointer)
    returns float
    external name '(shash_scancost)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="shash_update(pointer,pointer,pointer,pointer,pointer)" returnType="pointer,pointer,pointer,pointer,pointer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.shash_update(informix.pointer, informix.pointer, informix.pointer, informix.pointer, informix.pointer)
    returns int
    external name '(shash_stub5)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sourcetype_colnum(integer)" returnType="integer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.sourcetype_colnum(c_id integer)
returning integer
external name '(get_source_type_numcols)'
LANGUAGE C
END FUNCTION;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqlattributes(varchar,varchar,varchar,varchar,char)" returnType="varchar,varchar,varchar,varchar,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLAttributes(
	CatalogName     varchar(128),
        SchemaName      varchar(128),
        TypeName        varchar(128),
	AttributeName   varchar(128),
	Options         char(4000))
with (HANDLESNULLS)
external name '(SQLAttributes)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqlcamessageccsid(integer,smallint,varchar,char,integer,integer,integer,integer,integer,integer,char,char,varchar,inout varchar,out lvarchar,out integer,inout integer)" returnType="integer,smallint,varchar,char,integer,integer,integer,integer,integer,integer,char,char,varchar,inout varchar,out lvarchar,out integer,inout integer" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLCAMessageCCSID(
    SQLCode          INTEGER,
    SQLErrml         SMALLINT,
    SQLErrmc         VARCHAR(70),
    SQLErrp          CHAR(8),
    SQLErrd0         INTEGER,
    SQLErrd1         INTEGER,
    SQLErrd2         INTEGER,
    SQLErrd3         INTEGER,
    SQLErrd4         INTEGER,
    SQLErrd5         INTEGER,
    SQLWarn          CHAR(11),
    SQLState         CHAR(5),
    MessageFileName  VARCHAR(20),
    INOUT Locale     VARCHAR(33),
    OUT  Message     LVARCHAR(4096),
    OUT  Rcode       INTEGER,
    INOUT CCSID      INTEGER)
with (HANDLESNULLS)
external name '(SQLCAMessageCCSID)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqlcolprivileges(varchar,varchar,varchar,varchar,char)" returnType="varchar,varchar,varchar,varchar,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLColPrivileges(
	CatalogName	varchar(128),
	SchemaName	varchar(128),
	TableName	varchar(128),
 	ColumnName	varchar(128),
	Options		char(4000))
with (HANDLESNULLS)
external name '(SQLColPrivileges)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqlcolumns(varchar,varchar,varchar,varchar,char)" returnType="varchar,varchar,varchar,varchar,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLColumns(
	CatalogName	varchar(128),
	SchemaName	varchar(128),
	TableName	varchar(128),
 	ColumnName	varchar(128),
	Options		char(4000))
with (HANDLESNULLS)
external name '(SQLColumns)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqlforeignkeys(varchar,varchar,varchar,varchar,varchar,varchar,char)" returnType="varchar,varchar,varchar,varchar,varchar,varchar,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLForeignKeys(
	PKCatalogName	varchar(128),
	PKSchemaName	varchar(128),
	PKTableName	varchar(128),
	FKCatalogName	varchar(128),
	FKSchemaName	varchar(128),
	FKTableName	varchar(128),
	Options		char(4000))
with (HANDLESNULLS)
external name '(SQLForeignKeys)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqlfunctioncols(varchar,varchar,varchar,varchar,char)" returnType="varchar,varchar,varchar,varchar,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLFunctionCols(
	CatalogName     varchar(128),
        SchemaName      varchar(128),
        FuncName    	varchar(128),
	Paramname	varchar(218),
	Options		char(4000))
with (HANDLESNULLS)
external name '(SQLFunctionCols)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqlfunctions(varchar,varchar,varchar,char)" returnType="varchar,varchar,varchar,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLFunctions(
	CatalogName     varchar(128),
        SchemaName      varchar(128),
        FuncName    	varchar(128),
	Options		char(4000))
with (HANDLESNULLS)
external name '(SQLFunctions)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqlgettypeinfo(smallint,char)" returnType="smallint,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLGetTypeInfo(
	DataType        smallint,
	Options         char(4000))
with (HANDLESNULLS)
external name '(SQLGetTypeInfo)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqlprimarykeys(varchar,varchar,varchar,char)" returnType="varchar,varchar,varchar,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLPrimaryKeys(
	CatalogName	varchar(128),
	SchemaName	varchar(128),
	TableName	varchar(128),
	Options		char(4000))
with (HANDLESNULLS)
external name '(SQLPrimaryKeys)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqlprocedurecols(varchar,varchar,varchar,varchar,char)" returnType="varchar,varchar,varchar,varchar,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLProcedureCols(
	CatalogName	varchar(128),
	SchemaName	varchar(128),
	ProcName	varchar(128),
	ParamName	varchar(128),
	Options		char(4000))
with (HANDLESNULLS)
external name '(SQLProcedureCols)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqlprocedures(varchar,varchar,varchar,char)" returnType="varchar,varchar,varchar,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLProcedures(
	CatalogName	varchar(128),
	SchemaName	varchar(128),
	ProcName	varchar(128),
	Options		char(4000))
with (HANDLESNULLS)
external name '(SQLProcedures)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqlpseudocolumns(varchar,varchar,varchar,varchar,char)" returnType="varchar,varchar,varchar,varchar,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLPseudoColumns(
        CatalogName     varchar(128),
        SchemaName      varchar(128),
        TableName       varchar(128),
        ColumnName      varchar(128),
        Options         char(4000))
with (HANDLESNULLS)
external name '(SQLPseudoColumns)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqlschemas()" returnType="" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLSchemas()
with (HANDLESNULLS)
external name '(SQLSchemas)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqlspecialcolumns(smallint,varchar,varchar,varchar,smallint,smallint,char)" returnType="smallint,varchar,varchar,varchar,smallint,smallint,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLSpecialColumns(
        ColType         smallint,
        CatalogName     varchar(128),
        SchemaName      varchar(128),
        TableName       varchar(128),
        Scope           smallint,
        Nullable        smallint,
        Options         char(4000))
with (HANDLESNULLS)
external name '(SQLSpecialColumns)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqlstatistics(varchar,varchar,varchar,smallint,smallint,char)" returnType="varchar,varchar,varchar,smallint,smallint,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLStatistics(
	CatalogName	varchar(128),
	SchemaName	varchar(128),
	TableName 	varchar(128),
	Unique		Smallint,
	Approximate	Smallint,
	Options		char(4000))
with (HANDLESNULLS)
external name '(SQLStatistics)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqlsupertables(varchar,varchar,varchar,char)" returnType="varchar,varchar,varchar,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLSuperTables(
	CatalogName     varchar(128),
        SchemaName      varchar(128),
	TableName	varchar(128),
	Options         char(4000))
with (HANDLESNULLS)
external name '(SQLSuperTables)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqlsupertypes(varchar,varchar,varchar,char)" returnType="varchar,varchar,varchar,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLSuperTypes(
	CatalogName     varchar(128),
        SchemaName      varchar(128),
        TypeName	varchar(128),
	Options         char(4000))
with (HANDLESNULLS)
external name '(SQLSuperTypes)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqltableprivileges(varchar,varchar,varchar,char)" returnType="varchar,varchar,varchar,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLTablePrivileges(
	CatalogName	varchar(128),
	SchemaName	varchar(128),
	TableName 	varchar(128),
	Options		char(4000))
with (HANDLESNULLS)
external name '(SQLTablePrivileges)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqltables(varchar,varchar,varchar,char,char)" returnType="varchar,varchar,varchar,char,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLTables(
	CatalogName	varchar(128),
	SchemaName	varchar(128),
 	TableName	varchar(128),
	TableType_arg	char(4000),
	Options		char(4000))
with (HANDLESNULLS)
external name '(SQLTables)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sqludts(varchar,varchar,varchar,varchar,char)" returnType="varchar,varchar,varchar,varchar,char" securityType="Restricted" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create procedure SYSIBM.SQLUDTs(
	CatalogName     varchar(128),
        SchemaName      varchar(128),
	TypeName	varchar(128),
	Type		varchar(18),
	Options		char(4000))
with (HANDLESNULLS)
external name '(SQLUDTs)'
LANGUAGE C
END PROCEDURE;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="statout(stat)" returnType="stat" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.statout(informix.stat)
	returns informix.lvarchar
	external name '(showstat)'
	language C not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out blob)" returnType="stream,out blob" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamread(informix.stream, out informix.blob)
returns informix.integer
external name '(mi_streamread_lo)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out boolean)" returnType="stream,out boolean" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamread(informix.stream, out informix.boolean)
returns informix.integer
external name '(mi_streamread_boolean)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out bson)" returnType="stream,out bson" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.streamread(informix.stream, out informix.bson)
returns informix.integer
external name '(bson_streamread)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out char)" returnType="stream,out char" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamread(informix.stream, out informix.char)
returns informix.integer
external name '(mi_streamread_string)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out clob)" returnType="stream,out clob" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamread(informix.stream, out informix.clob)
returns informix.integer
external name '(mi_streamread_lo)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out collection)" returnType="stream,out collection" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamread(informix.stream, out informix.collection)
returns informix.integer
external name '(mi_streamread_collection)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out date)" returnType="stream,out date" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamread(informix.stream, out informix.date)
returns informix.integer
external name '(mi_streamread_date)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out datetime)" returnType="stream,out datetime" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamread(informix.stream, out datetime year to second)
returns informix.integer
external name '(mi_streamread_datetime)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out decimal)" returnType="stream,out decimal" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamread(informix.stream, out informix.decimal)
returns informix.integer
external name '(mi_streamread_decimal)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out float)" returnType="stream,out float" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamread(informix.stream, out informix.float)
returns informix.integer
external name '(mi_streamread_double)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out int8)" returnType="stream,out int8" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamread(informix.stream, out informix.int8)
returns informix.integer
external name '(mi_streamread_int8)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out integer)" returnType="stream,out integer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamread(informix.stream, out informix.integer)
returns informix.integer
external name '(mi_streamread_integer)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out interval)" returnType="stream,out interval" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamread(informix.stream, out interval hour to minute)
returns informix.integer
external name '(mi_streamread_interval)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out json)" returnType="stream,out json" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.streamread(informix.stream, out informix.json)
returns informix.integer
external name '(json_streamread)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out longlvarchar)" returnType="stream,out longlvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.streamread(informix.stream, out informix.longlvarchar)
returns informix.integer
external name '(llvc_streamread)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out lvarchar)" returnType="stream,out lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamread(informix.stream, out informix.lvarchar)
returns informix.integer
external name '(mi_streamread_lvarchar)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out money)" returnType="stream,out money" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamread(informix.stream, out informix.money)
returns informix.integer
external name '(mi_streamread_money)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out row)" returnType="stream,out row" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamread(informix.stream, out informix.row)
returns informix.integer
external name '(mi_streamread_row)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamread(stream,out smallfloat)" returnType="stream,out smallfloat" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamread(informix.stream, out informix.smallfloat)
returns informix.integer
external name '(mi_streamread_real)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,blob)" returnType="stream,blob" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamwrite(informix.stream, informix.blob)
returns informix.integer
external name '(mi_streamwrite_lo)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,boolean)" returnType="stream,boolean" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamwrite(informix.stream, informix.boolean)
returns informix.integer
external name '(mi_streamwrite_boolean)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,bson)" returnType="stream,bson" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.streamwrite(informix.stream, informix.bson)
returns informix.integer
external name '(bson_streamwrite)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,char)" returnType="stream,char" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamwrite(informix.stream, informix.char)
returns informix.integer
external name '(mi_streamwrite_string)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,clob)" returnType="stream,clob" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamwrite(informix.stream, informix.clob)
returns informix.integer
external name '(mi_streamwrite_lo)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,collection)" returnType="stream,collection" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamwrite(informix.stream, informix.collection)
returns informix.integer
external name '(mi_streamwrite_collection)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,date)" returnType="stream,date" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamwrite(informix.stream, informix.date)
returns informix.integer
external name '(mi_streamwrite_date)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,datetime)" returnType="stream,datetime" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamwrite(informix.stream, datetime year to second)
returns informix.integer
external name '(mi_streamwrite_datetime)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,decimal)" returnType="stream,decimal" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamwrite(informix.stream, informix.decimal)
returns informix.integer
external name '(mi_streamwrite_decimal)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,float)" returnType="stream,float" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamwrite(informix.stream, informix.float)
returns informix.integer
external name '(mi_streamwrite_double)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,int8)" returnType="stream,int8" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamwrite(informix.stream, informix.int8)
returns informix.integer
external name '(mi_streamwrite_int8)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,integer)" returnType="stream,integer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamwrite(informix.stream, informix.integer)
returns informix.integer
external name '(mi_streamwrite_integer)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,interval)" returnType="stream,interval" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamwrite(informix.stream, interval hour to minute)
returns informix.integer
external name '(mi_streamwrite_interval)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,json)" returnType="stream,json" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.streamwrite(informix.stream, informix.json)
returns informix.integer
external name '(json_streamwrite)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,longlvarchar)" returnType="stream,longlvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.streamwrite(informix.stream, informix.longlvarchar)
returns informix.integer
external name '(llvc_streamwrite)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,lvarchar)" returnType="stream,lvarchar" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamwrite(informix.stream, informix.lvarchar)
returns informix.integer
external name '(mi_streamwrite_lvarchar)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,money)" returnType="stream,money" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamwrite(informix.stream, informix.money)
returns informix.integer
external name '(mi_streamwrite_money)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,row)" returnType="stream,row" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamwrite(informix.stream, informix.row)
returns informix.integer
external name '(mi_streamwrite_row)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="streamwrite(stream,smallfloat)" returnType="stream,smallfloat" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.streamwrite(informix.stream, informix.smallfloat)
returns informix.integer
external name '(mi_streamwrite_real)' language c;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sysbldprepare(char,char)" returnType="char,char" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- Define BladeManager boot function
create function informix.sysbldprepare (char(64), char(18))
	returns integer
 	external name '$INFORMIXDIR/extend/ifxmngr/ifxmngr.bld(SYSBldCustomPrepare)'
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="sysfdist(integer,integer)" returnType="integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="spl"><![CDATA[create dba procedure informix.sysfdist (table_id int, column_no int)
   returning int, int, datetime year to fraction (5), stat;

   define v_tabauth      char(8);
   define v_colauth      char(3);
   define is_allowed     int;
   define search_columns int;
   define v_colno        smallint;
   define v_fragid       int;
   define v_seqno        int;
   define v_constr_time  datetime year to fraction(5);
   define v_mode         char(1);
   define v_encdist      stat;
   define v_owner        char(8);
   define user           procedure;

-- First verify that the current user has select privileges on this column

   let is_allowed = 0;
   let search_columns = 0;

   if user = 'informix' then
      let is_allowed = 1;
   else
      -- Check sysusers to see if the usertype is 'D', ie., the
      -- current user has dba privileges and may see any columns.
         select usertype
            into v_mode
            from informix.sysusers
            where username = user;
         if v_mode = 'D' then
            let is_allowed = 1;
         else
            -- See if the user owns the table, and therefore can see the columns.
            select owner
               into v_owner
               from informix.systables
               where tabid = table_id;
            if v_owner = user then
               let is_allowed = 1;
         end if
      end if
   end if

   if is_allowed = 0 then
      foreach
         select tabauth
            into v_tabauth
            from informix.systabauth
            where tabid = table_id and
                  (grantee = user or
                   grantee = 'public')
         if substr(v_tabauth, 1, 1) = 's' or substr(v_tabauth, 1, 1) = 'S' then
            let is_allowed = 1;
            exit foreach;
         elif substr(v_tabauth, 3, 1) = '*' then
            let search_columns = 1;
         end if
      end foreach
   end if

-- Search syscolauth only if user does not have select
-- privileges on all columns.  If the user has no select
-- privileges on any column, then we need search no further.

   if is_allowed = 0 and search_columns = 1 then
      foreach
         select colauth
            into v_colauth
            from informix.syscolauth
            where tabid = table_id and
                  colno = column_no and
                  (grantee = user or
                   grantee = 'public')
         if substr(v_colauth, 1, 1) = 's' or substr(v_colauth, 1, 1) = 'S' then
            let is_allowed = 1;
            exit foreach;
         end if
      end foreach
   end if

-- Return with no rows found if not allowed to select from
-- the column designated by (tabid,colno).

   if is_allowed = 0 then
      raise exception -272;
   end if

-- Now find the distribution rows
   foreach
      select  fragid, seqno, constr_time, encdist
         into v_fragid, v_seqno, v_constr_time, v_encdist
         from informix.sysfragdist
         where tabid = table_id and
               colno = column_no
         order by fragid
      return v_fragid, v_seqno, v_constr_time, v_encdist
         with resume;
   end foreach


-- Engine will return 100 to user

end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="syspurge(integer,integer)" returnType="integer,integer" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function
    informix.syspurge(loglevel integer default 0,
		      tabid integer default 0)
    returns integer
    external name '(ifx_syspurge)'
    language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="systdist(integer,integer)" returnType="integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="spl"><![CDATA[create dba procedure informix.systdist (table_id int, column_no int)
   returning int, datetime year to fraction (5), char(1),
             smallfloat, smallfloat, float , stat, char(1);

   define v_tabauth      char(8);
   define v_colauth      char(3);
   define is_allowed     int;
   define search_columns int;
   define v_colno        smallint;
   define v_seqno        int;
   define v_constr_time  datetime year to fraction(5);
   define v_mode         char(1);
   define v_resolution   smallfloat;
   define v_confidence   smallfloat;
   define v_encdat       stat;
   define v_owner        char(8);
   define user           procedure;
   define v_stattype	 char(1);
   define v_smplsize	 float;
   define v_rolename	 varchar(32);

-- First verify that the current user has select privileges on this column

   let is_allowed = 0;
   let search_columns = 0;

   if user = 'informix' then
      let is_allowed = 1;
   else
      -- Check sysusers to see if the usertype is 'D', ie., the
      -- current user has dba privileges and may see any columns.
      select usertype
         into v_mode
         from informix.sysusers
         where username = user;
      if v_mode = 'D' then
         let is_allowed = 1;
      else
         -- See if the user owns the table, and therefore can see the columns.
         select owner
            into v_owner
	    from informix.systables
	    where tabid = table_id;
         if v_owner = user then
            let is_allowed = 1;
         end if
      end if
   end if

   if is_allowed = 0 then
      foreach
         select tabauth
            into v_tabauth
            from informix.systabauth
            where tabid = table_id and
                  (grantee = user or
                   grantee = 'public')
         if substr(v_tabauth, 1, 1) = 's' or substr(v_tabauth, 1, 1) = 'S' then
            let is_allowed = 1;
            exit foreach;
         elif substr(v_tabauth, 3, 1) = '*' then
            let search_columns = 1;
         end if
      end foreach
   end if

-- Search syscolauth only if user does not have select
-- privileges on all columns.  If the user has no select
-- privileges on any column, then we need search no further.

   if is_allowed = 0 and search_columns = 1 then
      foreach
         select colauth
            into v_colauth
            from informix.syscolauth
            where tabid = table_id and
                  colno = column_no and
                  (grantee = user or
                   grantee = 'public')
         if substr(v_colauth, 1, 1) = 's' or substr(v_colauth, 1, 1) = 'S' then
            let is_allowed = 1;
            exit foreach;
         end if
      end foreach
   end if

-- Check user's current role for privileges on table and columns
   if is_allowed = 0 then
      select CURRENT_ROLE
         into v_rolename
         from informix.systables
         where tabid = 1;

      if v_rolename is NOT NULL then
         -- Check if user's current role has select privilege on table,
         -- and hence can see the columns
         foreach
            select tabauth
               into v_tabauth
               from informix.systabauth
               where tabid = table_id and
                     grantee = v_rolename
               if substr(v_tabauth, 1, 1) = 's' or
                  substr(v_tabauth, 1, 1) = 'S' then
                  let is_allowed = 1;
                  exit foreach;
               elif substr(v_tabauth, 3, 1) = '*' then
                  let search_columns = 1;
               end if
         end foreach

         -- Search syscolauth only if user's current role does not have select
         -- privileges on all columns. If the user's current role has no select
         -- privileges on any column, then we need search no further.

         if is_allowed = 0 and search_columns = 1 then
            foreach
               select colauth
                  into v_colauth
                  from informix.syscolauth
                  where tabid = table_id and
                        colno = column_no and
                        grantee = v_rolename
                  if substr(v_colauth, 1, 1) = 's' or
                     substr(v_colauth, 1, 1) = 'S' then
                     let is_allowed = 1;
                     exit foreach;
                  end if
            end foreach
         end if
      end if
   end if

-- Return with no rows found if not allowed to select from
-- the column designated by (tabid,colno).

   if is_allowed = 0 then
      raise exception -272;
   end if

-- Now find the distribution rows

   foreach
      select  seqno, constr_time, mode,
              resolution, confidence, smplsize, encdat, type
         into v_seqno, v_constr_time, v_mode,
              v_resolution, v_confidence, v_smplsize, v_encdat, v_stattype
         from informix.sysdistrib
         where tabid = table_id and
               colno = column_no
         order by seqno
      return v_seqno, v_constr_time, v_mode,
             v_resolution, v_confidence, v_smplsize, v_encdat, v_stattype
         with resume;
   end foreach

-- Engine will return 100 to user

end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="texttoclob(references text)" returnType="references text" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- cast from text to clob

create function informix.texttoclob(references text)
	returns informix.clob
	external name '(bytetoblob)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="texttoclob(references text,char,char)" returnType="references text,char,char" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.texttoclob(references text, char(128), char(128))
        returns informix.clob
        external name '(bytetoblob_colspec)'
        language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="texttoclob_pre1150(references text,char,char)" returnType="references text,char,char" securityType="Owner" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create function informix.texttoclob(references text, char(18), char(18))
	returns informix.clob
	external name '(bytetoblob_colspec)'
	language c not variant;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="trigger_action(integer,integer)" returnType="integer,integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.trigger_action (int, int)
	returns informix.lvarchar
	external name ''
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="trigger_cols(integer)" returnType="integer" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.trigger_cols(int)
	returns informix.lvarchar
	external name ''
	language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="unloading_module(varchar,varchar)" returnType="varchar,varchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[-- create a function to enable unloading of a module.
create dba function informix.unloading_module(varchar(255), varchar(255))
        returns int
        external name '' language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="unregisterjudtfuncs(varchar)" returnType="varchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="java"><![CDATA[create dba procedure sqlj.unregisterJUDTfuncs(varchar(255)) external name
 'informix.jvp.dbapplet.impl.JarHandler.unregisterJUDTfuncs(java.lang.String)'
 language java end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="true" name="unsetudtextname(varchar)" returnType="varchar" securityType="DBA" type="Procedure">
         <comment><![CDATA[N/A]]></comment>
         <definition language="java"><![CDATA[create dba procedure sqlj.unsetUDTExtName(udtSQLName varchar(255))
external name 'informix.jvp.dbapplet.impl.JarHandler.unsetUDTExternalName(java.lang.String)' language java end procedure;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="xsltransform(blob,blob)" returnType="blob,blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.xsltransform(informix.blob,
                                          informix.blob)
returns informix.lvarchar(32739)
with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
      PERCALL_COST = 32768 )
external name '$INFORMIXDIR/lib/libxml.udr(xsltransforminblob)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="xsltransform(blob,lvarchar)" returnType="blob,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.xsltransform(informix.blob,
                                          informix.lvarchar)
returns informix.lvarchar(32739)
with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
      PERCALL_COST = 32768 )
external name '$INFORMIXDIR/lib/libxml.udr(xsltransforminbloblv)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="xsltransform(clob,clob)" returnType="clob,clob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.xsltransform(informix.clob,
                                          informix.clob)
returns informix.lvarchar(32739)
with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
      PERCALL_COST = 32768 )
external name '$INFORMIXDIR/lib/libxml.udr(xsltransforminclob)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="xsltransform(clob,lvarchar)" returnType="clob,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.xsltransform(informix.clob,
                                          informix.lvarchar)
returns informix.lvarchar(32739)
with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
      PERCALL_COST = 32768 )
external name '$INFORMIXDIR/lib/libxml.udr(xsltransformincloblv)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="xsltransform(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.xsltransform(informix.lvarchar,
                                          informix.lvarchar)
returns informix.lvarchar(32739)
with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
      PERCALL_COST = 32768 )
external name '$INFORMIXDIR/lib/libxml.udr(xsltransform_lv)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="xsltransformasblob(blob,blob)" returnType="blob,blob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.xsltransformAsBlob(informix.blob,
                                                informix.blob)
returns informix.blob
with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
      PERCALL_COST = 32768 )
external name '$INFORMIXDIR/lib/libxml.udr(xsltransformblob)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="xsltransformasblob(blob,lvarchar)" returnType="blob,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.xsltransformAsBlob(informix.blob,
                                                informix.lvarchar)
returns informix.blob
with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
      PERCALL_COST = 32768 )
external name '$INFORMIXDIR/lib/libxml.udr(xsltransformblob_lv)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="xsltransformasblob(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.xsltransformAsBlob(informix.lvarchar,
                                                informix.lvarchar)
returns informix.blob
with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
      PERCALL_COST = 32768 )
external name '$INFORMIXDIR/lib/libxml.udr(xsltransformblobinlv)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="xsltransformasclob(clob,clob)" returnType="clob,clob" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.xsltransformAsClob(informix.clob,
                                                informix.clob)
returns informix.clob
with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
      PERCALL_COST = 32768 )
external name '$INFORMIXDIR/lib/libxml.udr(xsltransformclob)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="xsltransformasclob(clob,lvarchar)" returnType="clob,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.xsltransformAsClob(informix.clob,
                                                informix.lvarchar)
returns informix.clob
with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
      PERCALL_COST = 32768 )
external name '$INFORMIXDIR/lib/libxml.udr(xsltransformclob_lv)'
language C;]]></definition>
      </routine>
      <routine dataAccess="N/A" deterministic="false" name="xsltransformasclob(lvarchar,lvarchar)" returnType="lvarchar,lvarchar" securityType="DBA" type="Function">
         <comment><![CDATA[N/A]]></comment>
         <definition language="c"><![CDATA[create dba function informix.xsltransformAsClob(informix.lvarchar,
                                                informix.lvarchar)
returns informix.clob
with (NOT VARIANT, HANDLESNULLS, PARALLELIZABLE, CLASS = 'idsxmlvp',
      PERCALL_COST = 32768 )
external name '$INFORMIXDIR/lib/libxml.udr(xsltransformclobinlv)'
language C;]]></definition>
      </routine>
   </routines>
</database>
